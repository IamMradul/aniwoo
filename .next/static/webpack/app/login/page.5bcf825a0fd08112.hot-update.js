"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./components/providers/AuthProvider.tsx":
/*!***********************************************!*\
  !*** ./components/providers/AuthProvider.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [initialised, setInitialised] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [initError, setInitError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Debug: Log initialization state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"AuthProvider: initialised =\", initialised, \"user =\", user);\n    }, [\n        initialised,\n        user\n    ]);\n    const fetchUserProfile = async (userId, email, metadataName)=>{\n        try {\n            // Try to get profile from profiles table first - use maybeSingle to handle missing profiles\n            const { data: profile, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", userId).maybeSingle();\n            if (profile && !error) {\n                return {\n                    id: profile.id,\n                    name: profile.name || metadataName || email.split(\"@\")[0] || \"Aniwoo user\",\n                    email: profile.email || email,\n                    role: profile.role\n                };\n            }\n            // If profile doesn't exist, try to create it\n            if (error && error.code === \"PGRST116\") {\n                console.log(\"Profile not found, creating it...\");\n                const name = metadataName || email.split(\"@\")[0] || \"Aniwoo user\";\n                const { data: newProfile, error: createError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").insert({\n                    id: userId,\n                    name: name,\n                    email: email,\n                    role: null\n                }).select().single();\n                if (newProfile && !createError) {\n                    return {\n                        id: newProfile.id,\n                        name: newProfile.name || name,\n                        email: newProfile.email || email,\n                        role: newProfile.role\n                    };\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching profile:\", error);\n        // Continue to fallback\n        }\n        // Fallback to auth metadata if profile doesn't exist or query fails\n        return {\n            id: userId,\n            name: metadataName || email.split(\"@\")[0] || \"Aniwoo user\",\n            email: email,\n            role: undefined\n        };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let mounted = true;\n        // Wrap in try-catch to prevent errors from blocking render\n        try {\n            // Set up auth state change listener FIRST - this handles session restoration\n            const { data: { subscription } } = _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.onAuthStateChange(async (event, session)=>{\n                try {\n                    // Handle different auth events\n                    if (event === \"SIGNED_OUT\" || !session) {\n                        if (mounted) {\n                            setUser(null);\n                            setInitialised(true);\n                        }\n                        return;\n                    }\n                    const u = session === null || session === void 0 ? void 0 : session.user;\n                    if (!u) {\n                        if (mounted) {\n                            setUser(null);\n                            setInitialised(true);\n                        }\n                        return;\n                    }\n                    // For TOKEN_REFRESHED events, don't refetch everything - just keep current user\n                    if (event === \"TOKEN_REFRESHED\") {\n                        // Session refreshed, but user is still the same - don't refetch\n                        return;\n                    }\n                    // Handle INITIAL_SESSION and SIGNED_IN - restore user on page load/refresh\n                    if (event === \"INITIAL_SESSION\" || event === \"SIGNED_IN\") {\n                        try {\n                            var _u_user_metadata, _u_user_metadata1;\n                            const userData = await fetchUserProfile(u.id, u.email || \"\", ((_u_user_metadata = u.user_metadata) === null || _u_user_metadata === void 0 ? void 0 : _u_user_metadata.name) || ((_u_user_metadata1 = u.user_metadata) === null || _u_user_metadata1 === void 0 ? void 0 : _u_user_metadata1.full_name));\n                            if (mounted) {\n                                setUser(userData);\n                                setInitialised(true);\n                            }\n                        } catch (error) {\n                            console.error(\"Error fetching user profile on initial session:\", error);\n                            // Set user with basic info even if profile fetch fails\n                            if (mounted) {\n                                var _u_user_metadata2, _u_email;\n                                setUser({\n                                    id: u.id,\n                                    name: ((_u_user_metadata2 = u.user_metadata) === null || _u_user_metadata2 === void 0 ? void 0 : _u_user_metadata2.name) || ((_u_email = u.email) === null || _u_email === void 0 ? void 0 : _u_email.split(\"@\")[0]) || \"User\",\n                                    email: u.email || \"\",\n                                    role: undefined\n                                });\n                                setInitialised(true);\n                            }\n                        }\n                        return;\n                    }\n                    // On sign up or sign in, ensure profile exists\n                    if (event === \"SIGNED_IN\" || event === \"SIGNED_UP\") {\n                        try {\n                            var _u_user_metadata3, _u_user_metadata4, _u_email1;\n                            const metadataName = ((_u_user_metadata3 = u.user_metadata) === null || _u_user_metadata3 === void 0 ? void 0 : _u_user_metadata3.name) || ((_u_user_metadata4 = u.user_metadata) === null || _u_user_metadata4 === void 0 ? void 0 : _u_user_metadata4.full_name);\n                            const name = metadataName || ((_u_email1 = u.email) === null || _u_email1 === void 0 ? void 0 : _u_email1.split(\"@\")[0]) || \"Aniwoo user\";\n                            // Check if there's a pending OAuth role from Google sign-in\n                            const pendingRole =  true ? localStorage.getItem(\"pending_oauth_role\") : 0;\n                            // Upsert profile to ensure it exists (preserve existing role if set, use pending role for new OAuth users)\n                            const { data: existingProfile } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"role\").eq(\"id\", u.id).maybeSingle();\n                            const roleToUse = (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.role) || pendingRole || null;\n                            await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").upsert({\n                                id: u.id,\n                                name: name,\n                                email: u.email || \"\",\n                                role: roleToUse,\n                                updated_at: new Date().toISOString()\n                            }, {\n                                onConflict: \"id\"\n                            });\n                            // Clear pending role after using it\n                            if (pendingRole && \"object\" !== \"undefined\") {\n                                localStorage.removeItem(\"pending_oauth_role\");\n                            }\n                        } catch (error) {\n                            console.error(\"Error upserting profile:\", error);\n                        // Continue even if profile upsert fails\n                        }\n                    }\n                    // Handle SIGNED_UP events\n                    if (event === \"SIGNED_UP\") {\n                        try {\n                            var _u_user_metadata5, _u_user_metadata6;\n                            const userData = await fetchUserProfile(u.id, u.email || \"\", ((_u_user_metadata5 = u.user_metadata) === null || _u_user_metadata5 === void 0 ? void 0 : _u_user_metadata5.name) || ((_u_user_metadata6 = u.user_metadata) === null || _u_user_metadata6 === void 0 ? void 0 : _u_user_metadata6.full_name));\n                            if (mounted) {\n                                setUser(userData);\n                            }\n                        } catch (error) {\n                            console.error(\"Error fetching user profile in auth state change:\", error);\n                            // Set user with basic info even if profile fetch fails\n                            if (mounted) {\n                                var _u_user_metadata7, _u_email2;\n                                setUser({\n                                    id: u.id,\n                                    name: ((_u_user_metadata7 = u.user_metadata) === null || _u_user_metadata7 === void 0 ? void 0 : _u_user_metadata7.name) || ((_u_email2 = u.email) === null || _u_email2 === void 0 ? void 0 : _u_email2.split(\"@\")[0]) || \"User\",\n                                    email: u.email || \"\",\n                                    role: undefined\n                                });\n                            }\n                        }\n                    }\n                } catch (error) {\n                    console.error(\"Error in auth state change:\", error);\n                    // Don't clear user on error - keep current state\n                    if (mounted) {\n                        setInitialised(true);\n                    }\n                }\n            });\n            // Initialize - check current session after listener is set up\n            const init = async ()=>{\n                try {\n                    // Get current session - this will trigger INITIAL_SESSION event\n                    const { data: { session } } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.getSession();\n                    // If no session, mark as initialized (user is logged out)\n                    if (!session && mounted) {\n                        setInitialised(true);\n                        return;\n                    }\n                    // If session exists, INITIAL_SESSION event should handle user restoration\n                    // But set a shorter timeout as backup (safety timeout will also catch this)\n                    if (session && mounted) {\n                        setTimeout(()=>{\n                            if (mounted && !initialised) {\n                                var _u_user_metadata, _u_email;\n                                // Fallback: if INITIAL_SESSION didn't fire, initialize anyway\n                                const u = session.user;\n                                setUser({\n                                    id: u.id,\n                                    name: ((_u_user_metadata = u.user_metadata) === null || _u_user_metadata === void 0 ? void 0 : _u_user_metadata.name) || ((_u_email = u.email) === null || _u_email === void 0 ? void 0 : _u_email.split(\"@\")[0]) || \"User\",\n                                    email: u.email || \"\",\n                                    role: undefined\n                                });\n                                setInitialised(true);\n                            }\n                        }, 500); // Shorter timeout - safety timeout will catch if this doesn't\n                    }\n                } catch (error) {\n                    console.error(\"Error in init:\", error);\n                    if (mounted) {\n                        setInitialised(true);\n                    }\n                }\n            };\n            // Small delay to ensure listener is set up first\n            setTimeout(()=>{\n                void init();\n            }, 50);\n            // Safety timeout - always initialize after 1000ms max for faster loading\n            // Increased timeout to give Supabase more time to respond\n            const safetyTimeout = setTimeout(()=>{\n                if (mounted && !initialised) {\n                    console.warn(\"Auth initialization timeout - forcing initialization\");\n                    setInitialised(true);\n                }\n            }, 1000);\n            return ()=>{\n                mounted = false;\n                subscription.unsubscribe();\n                clearTimeout(safetyTimeout);\n            };\n        } catch (error) {\n            console.error(\"Error setting up auth listener:\", error);\n            // Even if auth setup fails, mark as initialized so app can render\n            if (mounted) {\n                setInitialised(true);\n            }\n            return ()=>{\n                mounted = false;\n            };\n        }\n    }, []);\n    const login = async (email, password, role)=>{\n        try {\n            var _u_user_metadata;\n            const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signInWithPassword({\n                email,\n                password\n            });\n            if (error) {\n                console.error(\"Login error:\", error);\n                throw new Error(error.message || \"Failed to log in. Please check your credentials.\");\n            }\n            if (!data.user) {\n                throw new Error(\"No user data returned from login\");\n            }\n            const u = data.user;\n            // Wait a moment for the session to be fully established\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n            // Verify session exists\n            const { data: { session }, error: sessionError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.getSession();\n            if (sessionError || !session) {\n                console.error(\"Session error after login:\", sessionError);\n                throw new Error(\"Failed to establish session. Please try again.\");\n            }\n            // Update profile with role if not already set\n            try {\n                const { data: profile, error: profileError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"role\").eq(\"id\", u.id).maybeSingle();\n                if (profileError && profileError.code !== \"PGRST116\") {\n                    console.error(\"Error fetching profile:\", profileError);\n                }\n                if (!(profile === null || profile === void 0 ? void 0 : profile.role)) {\n                    const { error: upsertError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").upsert({\n                        id: u.id,\n                        role: role,\n                        updated_at: new Date().toISOString()\n                    }, {\n                        onConflict: \"id\"\n                    });\n                    if (upsertError) {\n                        console.error(\"Error updating profile role:\", upsertError);\n                    // Don't throw - role update is optional\n                    }\n                }\n            } catch (profileErr) {\n                console.error(\"Error handling profile:\", profileErr);\n            // Continue even if profile update fails\n            }\n            // Fetch profile from database\n            const userData = await fetchUserProfile(u.id, u.email || \"\", (_u_user_metadata = u.user_metadata) === null || _u_user_metadata === void 0 ? void 0 : _u_user_metadata.name);\n            // Use role from profile if available, otherwise use the role passed in\n            const finalRole = userData.role || role;\n            setUser({\n                ...userData,\n                role: finalRole\n            });\n            // Verify user was set\n            if (!userData.id) {\n                throw new Error(\"Failed to load user profile\");\n            }\n        } catch (error) {\n            console.error(\"Login function error:\", error);\n            // Re-throw with better error message\n            throw error instanceof Error ? error : new Error(\"An unexpected error occurred during login\");\n        }\n    };\n    const register = async (name, email, password, role)=>{\n        try {\n            const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signUp({\n                email,\n                password,\n                options: {\n                    data: {\n                        name: name,\n                        full_name: name,\n                        role: role\n                    }\n                }\n            });\n            if (error) {\n                console.error(\"Supabase signup error:\", error);\n                throw new Error(error.message || \"Failed to create account\");\n            }\n            if (!data.user) {\n                throw new Error(\"User creation failed - no user data returned\");\n            }\n            const u = data.user;\n            // Wait for the database trigger to create the profile automatically\n            // The trigger runs with SECURITY DEFINER, so it bypasses RLS\n            await new Promise((resolve)=>setTimeout(resolve, 1500));\n            // Check if profile was created by trigger\n            let { data: existingProfile, error: checkError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"id, name, email, role, created_at\").eq(\"id\", u.id).maybeSingle();\n            if (checkError && checkError.code !== \"PGRST116\") {\n                console.error(\"Error checking profile:\", checkError);\n            }\n            const now = new Date().toISOString();\n            if (!existingProfile) {\n                // Profile wasn't created by trigger - try to create it manually\n                console.log(\"Profile not found, attempting to create manually...\");\n                const { error: insertError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").insert({\n                    id: u.id,\n                    name: name,\n                    email: u.email || email,\n                    role: role,\n                    created_at: now,\n                    updated_at: now\n                });\n                if (insertError) {\n                    console.error(\"Error inserting profile:\", insertError);\n                    // Wait a bit more and check again (trigger might be delayed)\n                    await new Promise((resolve)=>setTimeout(resolve, 1000));\n                    const { data: retryCheck } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", u.id).maybeSingle();\n                    if (!retryCheck) {\n                        throw new Error(\"Failed to create profile: \".concat(insertError.message, \". Please check database trigger setup.\"));\n                    }\n                    existingProfile = retryCheck;\n                }\n            } else {\n                // Profile exists - update it with role and name\n                const { error: updateError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").update({\n                    name: name,\n                    email: u.email || email,\n                    role: role,\n                    updated_at: now\n                }).eq(\"id\", u.id);\n                if (updateError) {\n                    console.error(\"Error updating profile:\", updateError);\n                    throw new Error(\"Failed to update profile: \".concat(updateError.message));\n                }\n            }\n            // Verify profile was created/updated\n            const { data: verifyProfile, error: verifyError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", u.id).single();\n            if (verifyError || !verifyProfile) {\n                console.error(\"Error verifying profile:\", verifyError);\n                throw new Error(\"Profile verification failed. Please try logging in.\");\n            }\n            // Fetch the complete profile\n            const userData = await fetchUserProfile(u.id, u.email || email, name);\n            setUser({\n                ...userData,\n                role: verifyProfile.role || role\n            });\n            console.log(\"Registration successful, profile created:\", verifyProfile);\n        } catch (error) {\n            console.error(\"Registration error:\", error);\n            throw error instanceof Error ? error : new Error(\"Registration failed\");\n        }\n    };\n    const loginWithGoogle = async (role)=>{\n        try {\n            // Store the role in localStorage so we can use it after OAuth callback\n            if (true) {\n                localStorage.setItem(\"pending_oauth_role\", role);\n            }\n            // Use Supabase's built-in OAuth\n            // This will redirect to Google, then back to Supabase's callback, then to our redirectTo URL\n            const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signInWithOAuth({\n                provider: \"google\",\n                options: {\n                    redirectTo:  true ? \"\".concat(window.location.origin, \"/auth/callback\") : 0,\n                    queryParams: {\n                        access_type: \"offline\",\n                        prompt: \"consent\"\n                    }\n                }\n            });\n            if (error) {\n                if (true) {\n                    localStorage.removeItem(\"pending_oauth_role\");\n                }\n                throw error;\n            }\n        // The OAuth flow will redirect to Google, then back to our callback\n        // The session will be handled by the auth state change listener\n        // No need to do anything else here - the redirect happens automatically\n        } catch (error) {\n            console.error(\"Error initiating Google OAuth:\", error);\n            if (true) {\n                localStorage.removeItem(\"pending_oauth_role\");\n            }\n            throw error;\n        }\n    };\n    const logout = async ()=>{\n        try {\n            await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signOut();\n            // Clear any local storage that might be causing issues\n            localStorage.removeItem(\"supabase.auth.token\");\n            setUser(null);\n        } catch (error) {\n            console.error(\"Error during logout:\", error);\n            // Still clear user state even if signOut fails\n            setUser(null);\n        }\n    };\n    // Always render children immediately - don't block on auth initialization\n    // Auth will update in the background\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isAuthenticated: !!user,\n            login,\n            register,\n            loginWithGoogle,\n            logout\n        },\n        children: initError ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"min-h-screen flex items-center justify-center bg-light p-4\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"max-w-md w-full rounded-2xl bg-white p-8 shadow-lg text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-slate-600 mb-4\",\n                        children: initError\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n                        lineNumber: 540,\n                        columnNumber: 13\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>window.location.reload(),\n                        className: \"rounded-full bg-primary px-6 py-2 text-sm font-semibold text-white transition hover:bg-primary/90\",\n                        children: \"Reload Page\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n                        lineNumber: 541,\n                        columnNumber: 13\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n                lineNumber: 539,\n                columnNumber: 11\n            }, this)\n        }, void 0, false, {\n            fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n            lineNumber: 538,\n            columnNumber: 9\n        }, this) : children\n    }, void 0, false, {\n        fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n        lineNumber: 527,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"sthe5bh4a7WVQuYL3xA1DXqIFCE=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (!ctx) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return ctx;\n}\n_s1(useAuth, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcHJvdmlkZXJzL0F1dGhQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFa0Y7QUFDbEM7QUFrQmhELE1BQU1LLDRCQUFjTCxvREFBYUEsQ0FBK0JNO0FBRXpELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdQLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1EsYUFBYUMsZUFBZSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNVLFdBQVdDLGFBQWEsR0FBR1gsK0NBQVFBLENBQWdCO0lBRTFELGtDQUFrQztJQUNsQ0QsZ0RBQVNBLENBQUM7UUFDUmEsUUFBUUMsR0FBRyxDQUFDLCtCQUErQkwsYUFBYSxVQUFVRjtJQUNwRSxHQUFHO1FBQUNFO1FBQWFGO0tBQUs7SUFFdEIsTUFBTVEsbUJBQW1CLE9BQU9DLFFBQWdCQyxPQUFlQztRQUM3RCxJQUFJO1lBQ0YsNEZBQTRGO1lBQzVGLE1BQU0sRUFBRUMsTUFBTUMsT0FBTyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNbkIseURBQVFBLENBQUNvQixJQUFJLENBQUMsWUFBWUMsTUFBTSxDQUFDLEtBQUtDLEVBQUUsQ0FBQyxNQUFNUixRQUFRUyxXQUFXO1lBRXpHLElBQUlMLFdBQVcsQ0FBQ0MsT0FBTztnQkFDckIsT0FBTztvQkFDTEssSUFBSU4sUUFBUU0sRUFBRTtvQkFDZEMsTUFBTVAsUUFBUU8sSUFBSSxJQUFJVCxnQkFBZ0JELE1BQU1XLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJO29CQUM3RFgsT0FBT0csUUFBUUgsS0FBSyxJQUFJQTtvQkFDeEJZLE1BQU1ULFFBQVFTLElBQUk7Z0JBQ3BCO1lBQ0Y7WUFFQSw2Q0FBNkM7WUFDN0MsSUFBSVIsU0FBU0EsTUFBTVMsSUFBSSxLQUFLLFlBQVk7Z0JBQ3RDakIs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QUFPNEM7QUFDVDtJQU5nQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wcm92aWRlcnMvQXV0aFByb3ZpZGVyLnRzeD9jY2I4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIFJlYWN0Tm9kZSwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZUNsaWVudCc7XHJcblxyXG50eXBlIFVzZXIgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxuICByb2xlPzogJ3ZldCcgfCAncGV0X293bmVyJztcclxufTtcclxuXHJcbnR5cGUgQXV0aENvbnRleHRWYWx1ZSA9IHtcclxuICB1c2VyOiBVc2VyIHwgbnVsbDtcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCByb2xlOiAndmV0JyB8ICdwZXRfb3duZXInKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHJlZ2lzdGVyOiAobmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCByb2xlOiAndmV0JyB8ICdwZXRfb3duZXInKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvZ2luV2l0aEdvb2dsZTogKHJvbGU6ICd2ZXQnIHwgJ3BldF9vd25lcicpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xyXG59O1xyXG5cclxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VmFsdWUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcclxuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2luaXRpYWxpc2VkLCBzZXRJbml0aWFsaXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2luaXRFcnJvciwgc2V0SW5pdEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBEZWJ1ZzogTG9nIGluaXRpYWxpemF0aW9uIHN0YXRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCdBdXRoUHJvdmlkZXI6IGluaXRpYWxpc2VkID0nLCBpbml0aWFsaXNlZCwgJ3VzZXIgPScsIHVzZXIpO1xyXG4gIH0sIFtpbml0aWFsaXNlZCwgdXNlcl0pO1xyXG5cclxuICBjb25zdCBmZXRjaFVzZXJQcm9maWxlID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBtZXRhZGF0YU5hbWU/OiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyeSB0byBnZXQgcHJvZmlsZSBmcm9tIHByb2ZpbGVzIHRhYmxlIGZpcnN0IC0gdXNlIG1heWJlU2luZ2xlIHRvIGhhbmRsZSBtaXNzaW5nIHByb2ZpbGVzXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogcHJvZmlsZSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJykuZXEoJ2lkJywgdXNlcklkKS5tYXliZVNpbmdsZSgpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHByb2ZpbGUgJiYgIWVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlkOiBwcm9maWxlLmlkLFxyXG4gICAgICAgICAgbmFtZTogcHJvZmlsZS5uYW1lIHx8IG1ldGFkYXRhTmFtZSB8fCBlbWFpbC5zcGxpdCgnQCcpWzBdIHx8ICdBbml3b28gdXNlcicsXHJcbiAgICAgICAgICBlbWFpbDogcHJvZmlsZS5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgICAgIHJvbGU6IHByb2ZpbGUucm9sZSBhcyAndmV0JyB8ICdwZXRfb3duZXInIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gSWYgcHJvZmlsZSBkb2Vzbid0IGV4aXN0LCB0cnkgdG8gY3JlYXRlIGl0XHJcbiAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Byb2ZpbGUgbm90IGZvdW5kLCBjcmVhdGluZyBpdC4uLicpO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBtZXRhZGF0YU5hbWUgfHwgZW1haWwuc3BsaXQoJ0AnKVswXSB8fCAnQW5pd29vIHVzZXInO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YTogbmV3UHJvZmlsZSwgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLmluc2VydCh7XHJcbiAgICAgICAgICBpZDogdXNlcklkLFxyXG4gICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgIGVtYWlsOiBlbWFpbCxcclxuICAgICAgICAgIHJvbGU6IG51bGxcclxuICAgICAgICB9KS5zZWxlY3QoKS5zaW5nbGUoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAobmV3UHJvZmlsZSAmJiAhY3JlYXRlRXJyb3IpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBuZXdQcm9maWxlLmlkLFxyXG4gICAgICAgICAgICBuYW1lOiBuZXdQcm9maWxlLm5hbWUgfHwgbmFtZSxcclxuICAgICAgICAgICAgZW1haWw6IG5ld1Byb2ZpbGUuZW1haWwgfHwgZW1haWwsXHJcbiAgICAgICAgICAgIHJvbGU6IG5ld1Byb2ZpbGUucm9sZSBhcyAndmV0JyB8ICdwZXRfb3duZXInIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZmlsZTonLCBlcnJvcik7XHJcbiAgICAgIC8vIENvbnRpbnVlIHRvIGZhbGxiYWNrXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZhbGxiYWNrIHRvIGF1dGggbWV0YWRhdGEgaWYgcHJvZmlsZSBkb2Vzbid0IGV4aXN0IG9yIHF1ZXJ5IGZhaWxzXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogdXNlcklkLFxyXG4gICAgICBuYW1lOiBtZXRhZGF0YU5hbWUgfHwgZW1haWwuc3BsaXQoJ0AnKVswXSB8fCAnQW5pd29vIHVzZXInLFxyXG4gICAgICBlbWFpbDogZW1haWwsXHJcbiAgICAgIHJvbGU6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbGV0IG1vdW50ZWQgPSB0cnVlO1xyXG5cclxuICAgIC8vIFdyYXAgaW4gdHJ5LWNhdGNoIHRvIHByZXZlbnQgZXJyb3JzIGZyb20gYmxvY2tpbmcgcmVuZGVyXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTZXQgdXAgYXV0aCBzdGF0ZSBjaGFuZ2UgbGlzdGVuZXIgRklSU1QgLSB0aGlzIGhhbmRsZXMgc2Vzc2lvbiByZXN0b3JhdGlvblxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgZGF0YTogeyBzdWJzY3JpcHRpb24gfVxyXG4gICAgICB9ID0gc3VwYWJhc2UuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShhc3luYyAoZXZlbnQsIHNlc3Npb24pID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IGF1dGggZXZlbnRzXHJcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnU0lHTkVEX09VVCcgfHwgIXNlc3Npb24pIHtcclxuICAgICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdSA9IHNlc3Npb24/LnVzZXI7XHJcbiAgICAgICAgaWYgKCF1KSB7XHJcbiAgICAgICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRJbml0aWFsaXNlZCh0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciBUT0tFTl9SRUZSRVNIRUQgZXZlbnRzLCBkb24ndCByZWZldGNoIGV2ZXJ5dGhpbmcgLSBqdXN0IGtlZXAgY3VycmVudCB1c2VyXHJcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnVE9LRU5fUkVGUkVTSEVEJykge1xyXG4gICAgICAgICAgLy8gU2Vzc2lvbiByZWZyZXNoZWQsIGJ1dCB1c2VyIGlzIHN0aWxsIHRoZSBzYW1lIC0gZG9uJ3QgcmVmZXRjaFxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIElOSVRJQUxfU0VTU0lPTiBhbmQgU0lHTkVEX0lOIC0gcmVzdG9yZSB1c2VyIG9uIHBhZ2UgbG9hZC9yZWZyZXNoXHJcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnSU5JVElBTF9TRVNTSU9OJyB8fCBldmVudCA9PT0gJ1NJR05FRF9JTicpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgZmV0Y2hVc2VyUHJvZmlsZShcclxuICAgICAgICAgICAgICB1LmlkLFxyXG4gICAgICAgICAgICAgIHUuZW1haWwgfHwgJycsXHJcbiAgICAgICAgICAgICAgKHUudXNlcl9tZXRhZGF0YSBhcyB7IG5hbWU/OiBzdHJpbmc7IGZ1bGxfbmFtZT86IHN0cmluZyB9IHwgbnVsbCk/Lm5hbWUgfHwgXHJcbiAgICAgICAgICAgICAgKHUudXNlcl9tZXRhZGF0YSBhcyB7IG5hbWU/OiBzdHJpbmc7IGZ1bGxfbmFtZT86IHN0cmluZyB9IHwgbnVsbCk/LmZ1bGxfbmFtZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgICAgICAgIHNldFVzZXIodXNlckRhdGEpO1xyXG4gICAgICAgICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyIHByb2ZpbGUgb24gaW5pdGlhbCBzZXNzaW9uOicsIGVycm9yKTtcclxuICAgICAgICAgICAgLy8gU2V0IHVzZXIgd2l0aCBiYXNpYyBpbmZvIGV2ZW4gaWYgcHJvZmlsZSBmZXRjaCBmYWlsc1xyXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgICAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IHUuaWQsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiAodS51c2VyX21ldGFkYXRhIGFzIHsgbmFtZT86IHN0cmluZyB9IHwgbnVsbCk/Lm5hbWUgfHwgdS5lbWFpbD8uc3BsaXQoJ0AnKVswXSB8fCAnVXNlcicsXHJcbiAgICAgICAgICAgICAgICBlbWFpbDogdS5lbWFpbCB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHJvbGU6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPbiBzaWduIHVwIG9yIHNpZ24gaW4sIGVuc3VyZSBwcm9maWxlIGV4aXN0c1xyXG4gICAgICAgIGlmIChldmVudCA9PT0gJ1NJR05FRF9JTicgfHwgZXZlbnQgPT09ICdTSUdORURfVVAnKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YU5hbWUgPSAodS51c2VyX21ldGFkYXRhIGFzIHsgbmFtZT86IHN0cmluZzsgZnVsbF9uYW1lPzogc3RyaW5nIH0gfCBudWxsKT8ubmFtZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodS51c2VyX21ldGFkYXRhIGFzIHsgbmFtZT86IHN0cmluZzsgZnVsbF9uYW1lPzogc3RyaW5nIH0gfCBudWxsKT8uZnVsbF9uYW1lO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbWV0YWRhdGFOYW1lIHx8IHUuZW1haWw/LnNwbGl0KCdAJylbMF0gfHwgJ0FuaXdvbyB1c2VyJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nIE9BdXRoIHJvbGUgZnJvbSBHb29nbGUgc2lnbi1pblxyXG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nUm9sZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BlbmRpbmdfb2F1dGhfcm9sZScpIGFzICd2ZXQnIHwgJ3BldF9vd25lcicgfCBudWxsIDogbnVsbDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFVwc2VydCBwcm9maWxlIHRvIGVuc3VyZSBpdCBleGlzdHMgKHByZXNlcnZlIGV4aXN0aW5nIHJvbGUgaWYgc2V0LCB1c2UgcGVuZGluZyByb2xlIGZvciBuZXcgT0F1dGggdXNlcnMpXHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdQcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLnNlbGVjdCgncm9sZScpLmVxKCdpZCcsIHUuaWQpLm1heWJlU2luZ2xlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvbGVUb1VzZSA9IGV4aXN0aW5nUHJvZmlsZT8ucm9sZSB8fCBwZW5kaW5nUm9sZSB8fCBudWxsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS51cHNlcnQoe1xyXG4gICAgICAgICAgICAgIGlkOiB1LmlkLFxyXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgZW1haWw6IHUuZW1haWwgfHwgJycsXHJcbiAgICAgICAgICAgICAgcm9sZTogcm9sZVRvVXNlLFxyXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgb25Db25mbGljdDogJ2lkJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgcm9sZSBhZnRlciB1c2luZyBpdFxyXG4gICAgICAgICAgICBpZiAocGVuZGluZ1JvbGUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncGVuZGluZ19vYXV0aF9yb2xlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwc2VydGluZyBwcm9maWxlOicsIGVycm9yKTtcclxuICAgICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiBwcm9maWxlIHVwc2VydCBmYWlsc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIFNJR05FRF9VUCBldmVudHNcclxuICAgICAgICBpZiAoZXZlbnQgPT09ICdTSUdORURfVVAnKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IGZldGNoVXNlclByb2ZpbGUoXHJcbiAgICAgICAgICAgICAgdS5pZCxcclxuICAgICAgICAgICAgICB1LmVtYWlsIHx8ICcnLFxyXG4gICAgICAgICAgICAgICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nOyBmdWxsX25hbWU/OiBzdHJpbmcgfSB8IG51bGwpPy5uYW1lIHx8IFxyXG4gICAgICAgICAgICAgICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nOyBmdWxsX25hbWU/OiBzdHJpbmcgfSB8IG51bGwpPy5mdWxsX25hbWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICBzZXRVc2VyKHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlciBwcm9maWxlIGluIGF1dGggc3RhdGUgY2hhbmdlOicsIGVycm9yKTtcclxuICAgICAgICAgICAgLy8gU2V0IHVzZXIgd2l0aCBiYXNpYyBpbmZvIGV2ZW4gaWYgcHJvZmlsZSBmZXRjaCBmYWlsc1xyXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgICAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IHUuaWQsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiAodS51c2VyX21ldGFkYXRhIGFzIHsgbmFtZT86IHN0cmluZyB9IHwgbnVsbCk/Lm5hbWUgfHwgdS5lbWFpbD8uc3BsaXQoJ0AnKVswXSB8fCAnVXNlcicsXHJcbiAgICAgICAgICAgICAgICBlbWFpbDogdS5lbWFpbCB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHJvbGU6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGF1dGggc3RhdGUgY2hhbmdlOicsIGVycm9yKTtcclxuICAgICAgICAvLyBEb24ndCBjbGVhciB1c2VyIG9uIGVycm9yIC0ga2VlcCBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSAtIGNoZWNrIGN1cnJlbnQgc2Vzc2lvbiBhZnRlciBsaXN0ZW5lciBpcyBzZXQgdXBcclxuICAgIGNvbnN0IGluaXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgc2Vzc2lvbiAtIHRoaXMgd2lsbCB0cmlnZ2VyIElOSVRJQUxfU0VTU0lPTiBldmVudFxyXG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vIHNlc3Npb24sIG1hcmsgYXMgaW5pdGlhbGl6ZWQgKHVzZXIgaXMgbG9nZ2VkIG91dClcclxuICAgICAgICBpZiAoIXNlc3Npb24gJiYgbW91bnRlZCkge1xyXG4gICAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIHNlc3Npb24gZXhpc3RzLCBJTklUSUFMX1NFU1NJT04gZXZlbnQgc2hvdWxkIGhhbmRsZSB1c2VyIHJlc3RvcmF0aW9uXHJcbiAgICAgICAgLy8gQnV0IHNldCBhIHNob3J0ZXIgdGltZW91dCBhcyBiYWNrdXAgKHNhZmV0eSB0aW1lb3V0IHdpbGwgYWxzbyBjYXRjaCB0aGlzKVxyXG4gICAgICAgIGlmIChzZXNzaW9uICYmIG1vdW50ZWQpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobW91bnRlZCAmJiAhaW5pdGlhbGlzZWQpIHtcclxuICAgICAgICAgICAgICAvLyBGYWxsYmFjazogaWYgSU5JVElBTF9TRVNTSU9OIGRpZG4ndCBmaXJlLCBpbml0aWFsaXplIGFueXdheVxyXG4gICAgICAgICAgICAgIGNvbnN0IHUgPSBzZXNzaW9uLnVzZXI7XHJcbiAgICAgICAgICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgICAgICAgICBpZDogdS5pZCxcclxuICAgICAgICAgICAgICAgIG5hbWU6ICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nIH0gfCBudWxsKT8ubmFtZSB8fCB1LmVtYWlsPy5zcGxpdCgnQCcpWzBdIHx8ICdVc2VyJyxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB1LmVtYWlsIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9sZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDUwMCk7IC8vIFNob3J0ZXIgdGltZW91dCAtIHNhZmV0eSB0aW1lb3V0IHdpbGwgY2F0Y2ggaWYgdGhpcyBkb2Vzbid0XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGluaXQ6JywgZXJyb3IpO1xyXG4gICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICBzZXRJbml0aWFsaXNlZCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGxpc3RlbmVyIGlzIHNldCB1cCBmaXJzdFxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHZvaWQgaW5pdCgpO1xyXG4gICAgfSwgNTApO1xyXG4gICAgXHJcbiAgICAvLyBTYWZldHkgdGltZW91dCAtIGFsd2F5cyBpbml0aWFsaXplIGFmdGVyIDEwMDBtcyBtYXggZm9yIGZhc3RlciBsb2FkaW5nXHJcbiAgICAvLyBJbmNyZWFzZWQgdGltZW91dCB0byBnaXZlIFN1cGFiYXNlIG1vcmUgdGltZSB0byByZXNwb25kXHJcbiAgICBjb25zdCBzYWZldHlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmIChtb3VudGVkICYmICFpbml0aWFsaXNlZCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQXV0aCBpbml0aWFsaXphdGlvbiB0aW1lb3V0IC0gZm9yY2luZyBpbml0aWFsaXphdGlvbicpO1xyXG4gICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDAwKTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIGNsZWFyVGltZW91dChzYWZldHlUaW1lb3V0KTtcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgdXAgYXV0aCBsaXN0ZW5lcjonLCBlcnJvcik7XHJcbiAgICAgIC8vIEV2ZW4gaWYgYXV0aCBzZXR1cCBmYWlscywgbWFyayBhcyBpbml0aWFsaXplZCBzbyBhcHAgY2FuIHJlbmRlclxyXG4gICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgcm9sZTogJ3ZldCcgfCAncGV0X293bmVyJykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoeyBlbWFpbCwgcGFzc3dvcmQgfSk7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGxvZyBpbi4gUGxlYXNlIGNoZWNrIHlvdXIgY3JlZGVudGlhbHMuJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGF0YS51c2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGRhdGEgcmV0dXJuZWQgZnJvbSBsb2dpbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1ID0gZGF0YS51c2VyO1xyXG5cclxuICAgICAgLy8gV2FpdCBhIG1vbWVudCBmb3IgdGhlIHNlc3Npb24gdG8gYmUgZnVsbHkgZXN0YWJsaXNoZWRcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IHNlc3Npb24gZXhpc3RzXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xyXG4gICAgICBpZiAoc2Vzc2lvbkVycm9yIHx8ICFzZXNzaW9uKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBlcnJvciBhZnRlciBsb2dpbjonLCBzZXNzaW9uRXJyb3IpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGVzdGFibGlzaCBzZXNzaW9uLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcHJvZmlsZSB3aXRoIHJvbGUgaWYgbm90IGFscmVhZHkgc2V0XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9maWxlLCBlcnJvcjogcHJvZmlsZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcclxuICAgICAgICAgIC5zZWxlY3QoJ3JvbGUnKVxyXG4gICAgICAgICAgLmVxKCdpZCcsIHUuaWQpXHJcbiAgICAgICAgICAubWF5YmVTaW5nbGUoKTtcclxuXHJcbiAgICAgICAgaWYgKHByb2ZpbGVFcnJvciAmJiBwcm9maWxlRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2Jykge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZmlsZTonLCBwcm9maWxlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFwcm9maWxlPy5yb2xlKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGVycm9yOiB1cHNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS51cHNlcnQoe1xyXG4gICAgICAgICAgICBpZDogdS5pZCxcclxuICAgICAgICAgICAgcm9sZTogcm9sZSxcclxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIG9uQ29uZmxpY3Q6ICdpZCdcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmICh1cHNlcnRFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9maWxlIHJvbGU6JywgdXBzZXJ0RXJyb3IpO1xyXG4gICAgICAgICAgICAvLyBEb24ndCB0aHJvdyAtIHJvbGUgdXBkYXRlIGlzIG9wdGlvbmFsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChwcm9maWxlRXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgcHJvZmlsZTonLCBwcm9maWxlRXJyKTtcclxuICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIHByb2ZpbGUgdXBkYXRlIGZhaWxzXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEZldGNoIHByb2ZpbGUgZnJvbSBkYXRhYmFzZVxyXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IGZldGNoVXNlclByb2ZpbGUoXHJcbiAgICAgICAgdS5pZCxcclxuICAgICAgICB1LmVtYWlsIHx8ICcnLFxyXG4gICAgICAgICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nIH0gfCBudWxsKT8ubmFtZVxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgLy8gVXNlIHJvbGUgZnJvbSBwcm9maWxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVzZSB0aGUgcm9sZSBwYXNzZWQgaW5cclxuICAgICAgY29uc3QgZmluYWxSb2xlID0gdXNlckRhdGEucm9sZSB8fCByb2xlO1xyXG4gICAgICBzZXRVc2VyKHsgLi4udXNlckRhdGEsIHJvbGU6IGZpbmFsUm9sZSB9KTtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSB1c2VyIHdhcyBzZXRcclxuICAgICAgaWYgKCF1c2VyRGF0YS5pZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgdXNlciBwcm9maWxlJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZnVuY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAvLyBSZS10aHJvdyB3aXRoIGJldHRlciBlcnJvciBtZXNzYWdlXHJcbiAgICAgIHRocm93IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCBkdXJpbmcgbG9naW4nKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCByZWdpc3RlciA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIHJvbGU6ICd2ZXQnIHwgJ3BldF9vd25lcicpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnblVwKHtcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICBvcHRpb25zOiB7IFxyXG4gICAgICAgICAgZGF0YTogeyBcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgZnVsbF9uYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICByb2xlOiByb2xlXHJcbiAgICAgICAgICB9IFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBzaWdudXAgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gY3JlYXRlIGFjY291bnQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkYXRhLnVzZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgY3JlYXRpb24gZmFpbGVkIC0gbm8gdXNlciBkYXRhIHJldHVybmVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHUgPSBkYXRhLnVzZXI7XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZGF0YWJhc2UgdHJpZ2dlciB0byBjcmVhdGUgdGhlIHByb2ZpbGUgYXV0b21hdGljYWxseVxyXG4gICAgICAvLyBUaGUgdHJpZ2dlciBydW5zIHdpdGggU0VDVVJJVFkgREVGSU5FUiwgc28gaXQgYnlwYXNzZXMgUkxTXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTAwKSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBwcm9maWxlIHdhcyBjcmVhdGVkIGJ5IHRyaWdnZXJcclxuICAgICAgbGV0IHsgZGF0YTogZXhpc3RpbmdQcm9maWxlLCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBlbWFpbCwgcm9sZSwgY3JlYXRlZF9hdCcpXHJcbiAgICAgICAgLmVxKCdpZCcsIHUuaWQpXHJcbiAgICAgICAgLm1heWJlU2luZ2xlKCk7XHJcblxyXG4gICAgICBpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwcm9maWxlOicsIGNoZWNrRXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcblxyXG4gICAgICBpZiAoIWV4aXN0aW5nUHJvZmlsZSkge1xyXG4gICAgICAgIC8vIFByb2ZpbGUgd2Fzbid0IGNyZWF0ZWQgYnkgdHJpZ2dlciAtIHRyeSB0byBjcmVhdGUgaXQgbWFudWFsbHlcclxuICAgICAgICBjb25zb2xlLmxvZygnUHJvZmlsZSBub3QgZm91bmQsIGF0dGVtcHRpbmcgdG8gY3JlYXRlIG1hbnVhbGx5Li4uJyk7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuaW5zZXJ0KHtcclxuICAgICAgICAgIGlkOiB1LmlkLFxyXG4gICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgIGVtYWlsOiB1LmVtYWlsIHx8IGVtYWlsLFxyXG4gICAgICAgICAgcm9sZTogcm9sZSxcclxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5vdyxcclxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5vd1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluc2VydGluZyBwcm9maWxlOicsIGluc2VydEVycm9yKTtcclxuICAgICAgICAgIC8vIFdhaXQgYSBiaXQgbW9yZSBhbmQgY2hlY2sgYWdhaW4gKHRyaWdnZXIgbWlnaHQgYmUgZGVsYXllZClcclxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHJldHJ5Q2hlY2sgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgICAgICAuZXEoJ2lkJywgdS5pZClcclxuICAgICAgICAgICAgLm1heWJlU2luZ2xlKCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghcmV0cnlDaGVjaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcHJvZmlsZTogJHtpbnNlcnRFcnJvci5tZXNzYWdlfS4gUGxlYXNlIGNoZWNrIGRhdGFiYXNlIHRyaWdnZXIgc2V0dXAuYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBleGlzdGluZ1Byb2ZpbGUgPSByZXRyeUNoZWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBQcm9maWxlIGV4aXN0cyAtIHVwZGF0ZSBpdCB3aXRoIHJvbGUgYW5kIG5hbWVcclxuICAgICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgZW1haWw6IHUuZW1haWwgfHwgZW1haWwsXHJcbiAgICAgICAgICAgIHJvbGU6IHJvbGUsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5vd1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5lcSgnaWQnLCB1LmlkKTtcclxuXHJcbiAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9maWxlOicsIHVwZGF0ZUVycm9yKTtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWZXJpZnkgcHJvZmlsZSB3YXMgY3JlYXRlZC91cGRhdGVkXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogdmVyaWZ5UHJvZmlsZSwgZXJyb3I6IHZlcmlmeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCdpZCcsIHUuaWQpXHJcbiAgICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgICAgaWYgKHZlcmlmeUVycm9yIHx8ICF2ZXJpZnlQcm9maWxlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIHByb2ZpbGU6JywgdmVyaWZ5RXJyb3IpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZmlsZSB2ZXJpZmljYXRpb24gZmFpbGVkLiBQbGVhc2UgdHJ5IGxvZ2dpbmcgaW4uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZldGNoIHRoZSBjb21wbGV0ZSBwcm9maWxlXHJcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgZmV0Y2hVc2VyUHJvZmlsZSh1LmlkLCB1LmVtYWlsIHx8IGVtYWlsLCBuYW1lKTtcclxuICAgICAgXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIC4uLnVzZXJEYXRhLFxyXG4gICAgICAgIHJvbGU6IHZlcmlmeVByb2ZpbGUucm9sZSB8fCByb2xlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ1JlZ2lzdHJhdGlvbiBzdWNjZXNzZnVsLCBwcm9maWxlIGNyZWF0ZWQ6JywgdmVyaWZ5UHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlZ2lzdHJhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignUmVnaXN0cmF0aW9uIGZhaWxlZCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGxvZ2luV2l0aEdvb2dsZSA9IGFzeW5jIChyb2xlOiAndmV0JyB8ICdwZXRfb3duZXInKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTdG9yZSB0aGUgcm9sZSBpbiBsb2NhbFN0b3JhZ2Ugc28gd2UgY2FuIHVzZSBpdCBhZnRlciBPQXV0aCBjYWxsYmFja1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGVuZGluZ19vYXV0aF9yb2xlJywgcm9sZSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFVzZSBTdXBhYmFzZSdzIGJ1aWx0LWluIE9BdXRoXHJcbiAgICAgIC8vIFRoaXMgd2lsbCByZWRpcmVjdCB0byBHb29nbGUsIHRoZW4gYmFjayB0byBTdXBhYmFzZSdzIGNhbGxiYWNrLCB0aGVuIHRvIG91ciByZWRpcmVjdFRvIFVSTFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhPQXV0aCh7XHJcbiAgICAgICAgcHJvdmlkZXI6ICdnb29nbGUnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIHJlZGlyZWN0VG86IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vYXV0aC9jYWxsYmFja2AgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICBxdWVyeVBhcmFtczoge1xyXG4gICAgICAgICAgICBhY2Nlc3NfdHlwZTogJ29mZmxpbmUnLFxyXG4gICAgICAgICAgICBwcm9tcHQ6ICdjb25zZW50JyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwZW5kaW5nX29hdXRoX3JvbGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSBPQXV0aCBmbG93IHdpbGwgcmVkaXJlY3QgdG8gR29vZ2xlLCB0aGVuIGJhY2sgdG8gb3VyIGNhbGxiYWNrXHJcbiAgICAgIC8vIFRoZSBzZXNzaW9uIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgYXV0aCBzdGF0ZSBjaGFuZ2UgbGlzdGVuZXJcclxuICAgICAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZyBlbHNlIGhlcmUgLSB0aGUgcmVkaXJlY3QgaGFwcGVucyBhdXRvbWF0aWNhbGx5XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYXRpbmcgR29vZ2xlIE9BdXRoOicsIGVycm9yKTtcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BlbmRpbmdfb2F1dGhfcm9sZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGxvZ291dCA9IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbk91dCgpO1xyXG4gICAgICAvLyBDbGVhciBhbnkgbG9jYWwgc3RvcmFnZSB0aGF0IG1pZ2h0IGJlIGNhdXNpbmcgaXNzdWVzXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzdXBhYmFzZS5hdXRoLnRva2VuJyk7XHJcbiAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgbG9nb3V0OicsIGVycm9yKTtcclxuICAgICAgLy8gU3RpbGwgY2xlYXIgdXNlciBzdGF0ZSBldmVuIGlmIHNpZ25PdXQgZmFpbHNcclxuICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBBbHdheXMgcmVuZGVyIGNoaWxkcmVuIGltbWVkaWF0ZWx5IC0gZG9uJ3QgYmxvY2sgb24gYXV0aCBpbml0aWFsaXphdGlvblxyXG4gIC8vIEF1dGggd2lsbCB1cGRhdGUgaW4gdGhlIGJhY2tncm91bmRcclxuICByZXR1cm4gKFxyXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyXHJcbiAgICAgIHZhbHVlPXt7XHJcbiAgICAgICAgdXNlcixcclxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6ICEhdXNlcixcclxuICAgICAgICBsb2dpbixcclxuICAgICAgICByZWdpc3RlcixcclxuICAgICAgICBsb2dpbldpdGhHb29nbGUsXHJcbiAgICAgICAgbG9nb3V0XHJcbiAgICAgIH19XHJcbiAgICA+XHJcbiAgICAgIHtpbml0RXJyb3IgPyAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctbGlnaHQgcC00XCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LW1kIHctZnVsbCByb3VuZGVkLTJ4bCBiZy13aGl0ZSBwLTggc2hhZG93LWxnIHRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc2xhdGUtNjAwIG1iLTRcIj57aW5pdEVycm9yfTwvcD5cclxuICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKX1cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWZ1bGwgYmctcHJpbWFyeSBweC02IHB5LTIgdGV4dC1zbSBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgdHJhbnNpdGlvbiBob3ZlcjpiZy1wcmltYXJ5LzkwXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIFJlbG9hZCBQYWdlXHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICkgOiAoXHJcbiAgICAgICAgY2hpbGRyZW5cclxuICAgICAgKX1cclxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUF1dGgoKSB7XHJcbiAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgaWYgKCFjdHgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gY3R4O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwic3VwYWJhc2UiLCJBdXRoQ29udGV4dCIsInVuZGVmaW5lZCIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwidXNlciIsInNldFVzZXIiLCJpbml0aWFsaXNlZCIsInNldEluaXRpYWxpc2VkIiwiaW5pdEVycm9yIiwic2V0SW5pdEVycm9yIiwiY29uc29sZSIsImxvZyIsImZldGNoVXNlclByb2ZpbGUiLCJ1c2VySWQiLCJlbWFpbCIsIm1ldGFkYXRhTmFtZSIsImRhdGEiLCJwcm9maWxlIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJtYXliZVNpbmdsZSIsImlkIiwibmFtZSIsInNwbGl0Iiwicm9sZSIsImNvZGUiLCJuZXdQcm9maWxlIiwiY3JlYXRlRXJyb3IiLCJpbnNlcnQiLCJzaW5nbGUiLCJtb3VudGVkIiwic3Vic2NyaXB0aW9uIiwiYXV0aCIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJzZXNzaW9uIiwidSIsInVzZXJEYXRhIiwidXNlcl9tZXRhZGF0YSIsImZ1bGxfbmFtZSIsInBlbmRpbmdSb2xlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImV4aXN0aW5nUHJvZmlsZSIsInJvbGVUb1VzZSIsInVwc2VydCIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJvbkNvbmZsaWN0IiwicmVtb3ZlSXRlbSIsImluaXQiLCJnZXRTZXNzaW9uIiwic2V0VGltZW91dCIsInNhZmV0eVRpbWVvdXQiLCJ3YXJuIiwidW5zdWJzY3JpYmUiLCJjbGVhclRpbWVvdXQiLCJsb2dpbiIsInBhc3N3b3JkIiwic2lnbkluV2l0aFBhc3N3b3JkIiwiRXJyb3IiLCJtZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXNzaW9uRXJyb3IiLCJwcm9maWxlRXJyb3IiLCJ1cHNlcnRFcnJvciIsInByb2ZpbGVFcnIiLCJmaW5hbFJvbGUiLCJyZWdpc3RlciIsInNpZ25VcCIsIm9wdGlvbnMiLCJjaGVja0Vycm9yIiwibm93IiwiaW5zZXJ0RXJyb3IiLCJjcmVhdGVkX2F0IiwicmV0cnlDaGVjayIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwidmVyaWZ5UHJvZmlsZSIsInZlcmlmeUVycm9yIiwibG9naW5XaXRoR29vZ2xlIiwic2V0SXRlbSIsInNpZ25JbldpdGhPQXV0aCIsInByb3ZpZGVyIiwicmVkaXJlY3RUbyIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwicXVlcnlQYXJhbXMiLCJhY2Nlc3NfdHlwZSIsInByb21wdCIsImxvZ291dCIsInNpZ25PdXQiLCJQcm92aWRlciIsInZhbHVlIiwiaXNBdXRoZW50aWNhdGVkIiwiZGl2IiwiY2xhc3NOYW1lIiwicCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJyZWxvYWQiLCJ1c2VBdXRoIiwiY3R4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/providers/AuthProvider.tsx\n"));

/***/ })

});