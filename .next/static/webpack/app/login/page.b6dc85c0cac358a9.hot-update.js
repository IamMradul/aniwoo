"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./components/providers/AuthProvider.tsx":
/*!***********************************************!*\
  !*** ./components/providers/AuthProvider.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [initialised, setInitialised] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [initError, setInitError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Debug: Log initialization state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"AuthProvider: initialised =\", initialised, \"user =\", user);\n    }, [\n        initialised,\n        user\n    ]);\n    const fetchUserProfile = async (userId, email, metadataName)=>{\n        try {\n            // Try to get profile from profiles table first - use maybeSingle to handle missing profiles\n            const { data: profile, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", userId).maybeSingle();\n            if (profile && !error) {\n                return {\n                    id: profile.id,\n                    name: profile.name || metadataName || email.split(\"@\")[0] || \"Aniwoo user\",\n                    email: profile.email || email,\n                    role: profile.role\n                };\n            }\n            // If profile doesn't exist, try to create it\n            if (error && error.code === \"PGRST116\") {\n                console.log(\"Profile not found, creating it...\");\n                const name = metadataName || email.split(\"@\")[0] || \"Aniwoo user\";\n                const { data: newProfile, error: createError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").insert({\n                    id: userId,\n                    name: name,\n                    email: email,\n                    role: null\n                }).select().single();\n                if (newProfile && !createError) {\n                    return {\n                        id: newProfile.id,\n                        name: newProfile.name || name,\n                        email: newProfile.email || email,\n                        role: newProfile.role\n                    };\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching profile:\", error);\n        // Continue to fallback\n        }\n        // Fallback to auth metadata if profile doesn't exist or query fails\n        return {\n            id: userId,\n            name: metadataName || email.split(\"@\")[0] || \"Aniwoo user\",\n            email: email,\n            role: undefined\n        };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let mounted = true;\n        // Wrap in try-catch to prevent errors from blocking render\n        try {\n            // Set up auth state change listener FIRST - this handles session restoration\n            const { data: { subscription } } = _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.onAuthStateChange(async (event, session)=>{\n                try {\n                    // Handle different auth events\n                    if (event === \"SIGNED_OUT\" || !session) {\n                        if (mounted) {\n                            setUser(null);\n                            setInitialised(true);\n                        }\n                        return;\n                    }\n                    const u = session === null || session === void 0 ? void 0 : session.user;\n                    if (!u) {\n                        if (mounted) {\n                            setUser(null);\n                            setInitialised(true);\n                        }\n                        return;\n                    }\n                    // For TOKEN_REFRESHED events, don't refetch everything - just keep current user\n                    if (event === \"TOKEN_REFRESHED\") {\n                        // Session refreshed, but user is still the same - don't refetch\n                        return;\n                    }\n                    // Handle INITIAL_SESSION and SIGNED_IN - restore user on page load/refresh\n                    if (event === \"INITIAL_SESSION\" || event === \"SIGNED_IN\") {\n                        try {\n                            var _u_user_metadata, _u_user_metadata1;\n                            const userData = await fetchUserProfile(u.id, u.email || \"\", ((_u_user_metadata = u.user_metadata) === null || _u_user_metadata === void 0 ? void 0 : _u_user_metadata.name) || ((_u_user_metadata1 = u.user_metadata) === null || _u_user_metadata1 === void 0 ? void 0 : _u_user_metadata1.full_name));\n                            if (mounted) {\n                                setUser(userData);\n                                setInitialised(true);\n                            }\n                        } catch (error) {\n                            console.error(\"Error fetching user profile on initial session:\", error);\n                            // Set user with basic info even if profile fetch fails\n                            if (mounted) {\n                                var _u_user_metadata2, _u_email;\n                                setUser({\n                                    id: u.id,\n                                    name: ((_u_user_metadata2 = u.user_metadata) === null || _u_user_metadata2 === void 0 ? void 0 : _u_user_metadata2.name) || ((_u_email = u.email) === null || _u_email === void 0 ? void 0 : _u_email.split(\"@\")[0]) || \"User\",\n                                    email: u.email || \"\",\n                                    role: undefined\n                                });\n                                setInitialised(true);\n                            }\n                        }\n                        return;\n                    }\n                    // On sign up or sign in, ensure profile exists\n                    if (event === \"SIGNED_IN\" || event === \"SIGNED_UP\") {\n                        try {\n                            var _u_user_metadata3, _u_user_metadata4, _u_email1;\n                            const metadataName = ((_u_user_metadata3 = u.user_metadata) === null || _u_user_metadata3 === void 0 ? void 0 : _u_user_metadata3.name) || ((_u_user_metadata4 = u.user_metadata) === null || _u_user_metadata4 === void 0 ? void 0 : _u_user_metadata4.full_name);\n                            const name = metadataName || ((_u_email1 = u.email) === null || _u_email1 === void 0 ? void 0 : _u_email1.split(\"@\")[0]) || \"Aniwoo user\";\n                            // Check if there's a pending OAuth role from Google sign-in\n                            const pendingRole =  true ? localStorage.getItem(\"pending_oauth_role\") : 0;\n                            // Upsert profile to ensure it exists (preserve existing role if set, use pending role for new OAuth users)\n                            const { data: existingProfile } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"role\").eq(\"id\", u.id).maybeSingle();\n                            const roleToUse = (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.role) || pendingRole || null;\n                            await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").upsert({\n                                id: u.id,\n                                name: name,\n                                email: u.email || \"\",\n                                role: roleToUse,\n                                updated_at: new Date().toISOString()\n                            }, {\n                                onConflict: \"id\"\n                            });\n                            // Clear pending role after using it\n                            if (pendingRole && \"object\" !== \"undefined\") {\n                                localStorage.removeItem(\"pending_oauth_role\");\n                            }\n                        } catch (error) {\n                            console.error(\"Error upserting profile:\", error);\n                        // Continue even if profile upsert fails\n                        }\n                    }\n                    // Handle SIGNED_UP events\n                    if (event === \"SIGNED_UP\") {\n                        try {\n                            var _u_user_metadata5, _u_user_metadata6;\n                            const userData = await fetchUserProfile(u.id, u.email || \"\", ((_u_user_metadata5 = u.user_metadata) === null || _u_user_metadata5 === void 0 ? void 0 : _u_user_metadata5.name) || ((_u_user_metadata6 = u.user_metadata) === null || _u_user_metadata6 === void 0 ? void 0 : _u_user_metadata6.full_name));\n                            if (mounted) {\n                                setUser(userData);\n                            }\n                        } catch (error) {\n                            console.error(\"Error fetching user profile in auth state change:\", error);\n                            // Set user with basic info even if profile fetch fails\n                            if (mounted) {\n                                var _u_user_metadata7, _u_email2;\n                                setUser({\n                                    id: u.id,\n                                    name: ((_u_user_metadata7 = u.user_metadata) === null || _u_user_metadata7 === void 0 ? void 0 : _u_user_metadata7.name) || ((_u_email2 = u.email) === null || _u_email2 === void 0 ? void 0 : _u_email2.split(\"@\")[0]) || \"User\",\n                                    email: u.email || \"\",\n                                    role: undefined\n                                });\n                            }\n                        }\n                    }\n                } catch (error) {\n                    console.error(\"Error in auth state change:\", error);\n                    // Don't clear user on error - keep current state\n                    if (mounted) {\n                        setInitialised(true);\n                    }\n                }\n            });\n            // Initialize - check current session after listener is set up\n            const init = async ()=>{\n                try {\n                    // Get current session - this will trigger INITIAL_SESSION event\n                    const { data: { session } } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.getSession();\n                    // If no session, mark as initialized (user is logged out)\n                    if (!session && mounted) {\n                        setInitialised(true);\n                        return;\n                    }\n                    // If session exists, INITIAL_SESSION event should handle user restoration\n                    // But set a shorter timeout as backup (safety timeout will also catch this)\n                    if (session && mounted) {\n                        setTimeout(()=>{\n                            if (mounted && !initialised) {\n                                var _u_user_metadata, _u_email;\n                                // Fallback: if INITIAL_SESSION didn't fire, initialize anyway\n                                const u = session.user;\n                                setUser({\n                                    id: u.id,\n                                    name: ((_u_user_metadata = u.user_metadata) === null || _u_user_metadata === void 0 ? void 0 : _u_user_metadata.name) || ((_u_email = u.email) === null || _u_email === void 0 ? void 0 : _u_email.split(\"@\")[0]) || \"User\",\n                                    email: u.email || \"\",\n                                    role: undefined\n                                });\n                                setInitialised(true);\n                            }\n                        }, 500); // Shorter timeout - safety timeout will catch if this doesn't\n                    }\n                } catch (error) {\n                    console.error(\"Error in init:\", error);\n                    if (mounted) {\n                        setInitialised(true);\n                    }\n                }\n            };\n            // Small delay to ensure listener is set up first\n            setTimeout(()=>{\n                void init();\n            }, 50);\n            // Safety timeout - always initialize after 1000ms max for faster loading\n            // Increased timeout to give Supabase more time to respond\n            const safetyTimeout = setTimeout(()=>{\n                if (mounted && !initialised) {\n                    console.warn(\"Auth initialization timeout - forcing initialization\");\n                    setInitialised(true);\n                }\n            }, 1000);\n            return ()=>{\n                mounted = false;\n                subscription.unsubscribe();\n                clearTimeout(safetyTimeout);\n            };\n        } catch (error) {\n            console.error(\"Error setting up auth listener:\", error);\n            // Even if auth setup fails, mark as initialized so app can render\n            if (mounted) {\n                setInitialised(true);\n            }\n            return ()=>{\n                mounted = false;\n            };\n        }\n    }, []);\n    const login = async (email, password, role)=>{\n        try {\n            var _u_user_metadata;\n            const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signInWithPassword({\n                email,\n                password\n            });\n            if (error) {\n                console.error(\"Login error:\", error);\n                throw new Error(error.message || \"Failed to log in. Please check your credentials.\");\n            }\n            if (!data.user) {\n                throw new Error(\"No user data returned from login\");\n            }\n            const u = data.user;\n            // Wait a moment for the session to be fully established\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n            // Verify session exists\n            const { data: { session }, error: sessionError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.getSession();\n            if (sessionError || !session) {\n                console.error(\"Session error after login:\", sessionError);\n                throw new Error(\"Failed to establish session. Please try again.\");\n            }\n            // Update profile with role if not already set\n            try {\n                const { data: profile, error: profileError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"role\").eq(\"id\", u.id).maybeSingle();\n                if (profileError && profileError.code !== \"PGRST116\") {\n                    console.error(\"Error fetching profile:\", profileError);\n                }\n                if (!(profile === null || profile === void 0 ? void 0 : profile.role)) {\n                    const { error: upsertError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").upsert({\n                        id: u.id,\n                        role: role,\n                        updated_at: new Date().toISOString()\n                    }, {\n                        onConflict: \"id\"\n                    });\n                    if (upsertError) {\n                        console.error(\"Error updating profile role:\", upsertError);\n                    // Don't throw - role update is optional\n                    }\n                }\n            } catch (profileErr) {\n                console.error(\"Error handling profile:\", profileErr);\n            // Continue even if profile update fails\n            }\n            // Fetch profile from database\n            const userData = await fetchUserProfile(u.id, u.email || \"\", (_u_user_metadata = u.user_metadata) === null || _u_user_metadata === void 0 ? void 0 : _u_user_metadata.name);\n            // Use role from profile if available, otherwise use the role passed in\n            const finalRole = userData.role || role;\n            setUser({\n                ...userData,\n                role: finalRole\n            });\n            // Verify user was set\n            if (!userData.id) {\n                throw new Error(\"Failed to load user profile\");\n            }\n        } catch (error) {\n            console.error(\"Login function error:\", error);\n            // Re-throw with better error message\n            throw error instanceof Error ? error : new Error(\"An unexpected error occurred during login\");\n        }\n    };\n    const register = async (name, email, password, role)=>{\n        try {\n            const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signUp({\n                email,\n                password,\n                options: {\n                    data: {\n                        name: name,\n                        full_name: name,\n                        role: role\n                    }\n                }\n            });\n            if (error) {\n                console.error(\"Supabase signup error:\", error);\n                throw new Error(error.message || \"Failed to create account\");\n            }\n            if (!data.user) {\n                throw new Error(\"User creation failed - no user data returned\");\n            }\n            const u = data.user;\n            // Wait for the database trigger to create the profile automatically\n            // The trigger runs with SECURITY DEFINER, so it bypasses RLS\n            await new Promise((resolve)=>setTimeout(resolve, 1500));\n            // Check if profile was created by trigger\n            let { data: existingProfile, error: checkError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"id, name, email, role, created_at\").eq(\"id\", u.id).maybeSingle();\n            if (checkError && checkError.code !== \"PGRST116\") {\n                console.error(\"Error checking profile:\", checkError);\n            }\n            const now = new Date().toISOString();\n            if (!existingProfile) {\n                // Profile wasn't created by trigger - try to create it manually\n                console.log(\"Profile not found, attempting to create manually...\");\n                const { error: insertError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").insert({\n                    id: u.id,\n                    name: name,\n                    email: u.email || email,\n                    role: role,\n                    created_at: now,\n                    updated_at: now\n                });\n                if (insertError) {\n                    console.error(\"Error inserting profile:\", insertError);\n                    // Wait a bit more and check again (trigger might be delayed)\n                    await new Promise((resolve)=>setTimeout(resolve, 1000));\n                    const { data: retryCheck } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", u.id).maybeSingle();\n                    if (!retryCheck) {\n                        throw new Error(\"Failed to create profile: \".concat(insertError.message, \". Please check database trigger setup.\"));\n                    }\n                    existingProfile = retryCheck;\n                }\n            } else {\n                // Profile exists - update it with role and name\n                const { error: updateError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").update({\n                    name: name,\n                    email: u.email || email,\n                    role: role,\n                    updated_at: now\n                }).eq(\"id\", u.id);\n                if (updateError) {\n                    console.error(\"Error updating profile:\", updateError);\n                    throw new Error(\"Failed to update profile: \".concat(updateError.message));\n                }\n            }\n            // Verify profile was created/updated\n            const { data: verifyProfile, error: verifyError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", u.id).single();\n            if (verifyError || !verifyProfile) {\n                console.error(\"Error verifying profile:\", verifyError);\n                throw new Error(\"Profile verification failed. Please try logging in.\");\n            }\n            // Fetch the complete profile\n            const userData = await fetchUserProfile(u.id, u.email || email, name);\n            setUser({\n                ...userData,\n                role: verifyProfile.role || role\n            });\n            console.log(\"Registration successful, profile created:\", verifyProfile);\n        } catch (error) {\n            console.error(\"Registration error:\", error);\n            throw error instanceof Error ? error : new Error(\"Registration failed\");\n        }\n    };\n    const loginWithGoogle = async (role)=>{\n        try {\n            // Store the role in localStorage so we can use it after OAuth callback\n            if (true) {\n                localStorage.setItem(\"pending_oauth_role\", role);\n            }\n            // Use Supabase's built-in OAuth\n            // This will redirect to Google, then back to Supabase's callback, then to our redirectTo URL\n            const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signInWithOAuth({\n                provider: \"google\",\n                options: {\n                    redirectTo:  true ? \"\".concat(window.location.origin, \"/auth/callback\") : 0,\n                    queryParams: {\n                        access_type: \"offline\",\n                        prompt: \"consent\"\n                    }\n                }\n            });\n            if (error) {\n                if (true) {\n                    localStorage.removeItem(\"pending_oauth_role\");\n                }\n                throw error;\n            }\n        // The OAuth flow will redirect to Google, then back to our callback\n        // The session will be handled by the auth state change listener\n        // No need to do anything else here - the redirect happens automatically\n        } catch (error) {\n            console.error(\"Error initiating Google OAuth:\", error);\n            if (true) {\n                localStorage.removeItem(\"pending_oauth_role\");\n            }\n            throw error;\n        }\n    };\n    const logout = async ()=>{\n        try {\n            console.log(\"Logging out...\");\n            // Sign out from Supabase\n            const { error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signOut();\n            if (error) {\n                console.error(\"Supabase signOut error:\", error);\n            }\n            // Clear local storage\n            if (true) {\n                localStorage.removeItem(\"supabase.auth.token\");\n                localStorage.removeItem(\"pending_oauth_role\");\n            }\n            // Clear user state\n            setUser(null);\n            console.log(\"Logout complete\");\n        } catch (error) {\n            console.error(\"Error during logout:\", error);\n            // Still clear user state even if signOut fails\n            setUser(null);\n        }\n    };\n    // Always render children immediately - don't block on auth initialization\n    // Auth will update in the background\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isAuthenticated: !!user,\n            login,\n            register,\n            loginWithGoogle,\n            logout\n        },\n        children: initError ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"min-h-screen flex items-center justify-center bg-light p-4\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"max-w-md w-full rounded-2xl bg-white p-8 shadow-lg text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-slate-600 mb-4\",\n                        children: initError\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n                        lineNumber: 552,\n                        columnNumber: 13\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>window.location.reload(),\n                        className: \"rounded-full bg-primary px-6 py-2 text-sm font-semibold text-white transition hover:bg-primary/90\",\n                        children: \"Reload Page\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n                        lineNumber: 553,\n                        columnNumber: 13\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n                lineNumber: 551,\n                columnNumber: 11\n            }, this)\n        }, void 0, false, {\n            fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n            lineNumber: 550,\n            columnNumber: 9\n        }, this) : children\n    }, void 0, false, {\n        fileName: \"D:\\\\Project\\\\aniwoo\\\\components\\\\providers\\\\AuthProvider.tsx\",\n        lineNumber: 539,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"sthe5bh4a7WVQuYL3xA1DXqIFCE=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (!ctx) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return ctx;\n}\n_s1(useAuth, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcHJvdmlkZXJzL0F1dGhQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFa0Y7QUFDbEM7QUFrQmhELE1BQU1LLDRCQUFjTCxvREFBYUEsQ0FBK0JNO0FBRXpELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdQLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1EsYUFBYUMsZUFBZSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNVLFdBQVdDLGFBQWEsR0FBR1gsK0NBQVFBLENBQWdCO0lBRTFELGtDQUFrQztJQUNsQ0QsZ0RBQVNBLENBQUM7UUFDUmEsUUFBUUMsR0FBRyxDQUFDLCtCQUErQkwsYUFBYSxVQUFVRjtJQUNwRSxHQUFHO1FBQUNFO1FBQWFGO0tBQUs7SUFFdEIsTUFBTVEsbUJBQW1CLE9BQU9DLFFBQWdCQyxPQUFlQztRQUM3RCxJQUFJO1lBQ0YsNEZBQTRGO1lBQzVGLE1BQU0sRUFBRUMsTUFBTUMsT0FBTyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNbkIseURBQVFBLENBQUNvQixJQUFJLENBQUMsWUFBWUMsTUFBTSxDQUFDLEtBQUtDLEVBQUUsQ0FBQyxNQUFNUixRQUFRUyxXQUFXO1lBRXpHLElBQUlMLFdBQVcsQ0FBQ0MsT0FBTztnQkFDckIsT0FBTztvQkFDTEssSUFBSU4sUUFBUU0sRUFBRTtvQkFDZEMsTUFBTVAsUUFBUU8sSUFBSSxJQUFJVCxnQkFBZ0JELE1BQU1XLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJO29CQUM3RFgsT0FBT0csUUFBUUgsS0FBSyxJQUFJQTtvQkFDeEJZLE1BQU1ULFFBQVFTLElBQUk7Z0JBQ3BCO1lBQ0Y7WUFFQSw2Q0FBNkM7WUFDN0MsSUFBSVIsU0FBU0EsTUFBTVMsSUFBSSxLQUFLLFlBQVk7Z0JBQ3RDakIs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U0FBUyxJQUFNZixPQUFPQyxRQUFRLENBQUNlLE1BQU07d0JBQ3JDSixXQUFVO2tDQUNYOzs7Ozs7Ozs7Ozs7Ozs7O21CQU1MbEc7Ozs7OztBQUlSO0dBOWhCZ0JEO0tBQUFBO0FBZ2lCVCxTQUFTd0c7O0lBQ2QsTUFBTUMsTUFBTS9HLGlEQUFVQSxDQUFDSTtJQUN2QixJQUFJLENBQUMyRyxLQUFLO1FBQ1IsTUFBTSxJQUFJNUMsTUFBTTtJQUNsQjtJQUNBLE9BQU80QztBQUNUO0lBTmdCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL3Byb3ZpZGVycy9BdXRoUHJvdmlkZXIudHN4P2NjYjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgUmVhY3ROb2RlLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlQ2xpZW50JztcclxuXHJcbnR5cGUgVXNlciA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBlbWFpbDogc3RyaW5nO1xyXG4gIHJvbGU/OiAndmV0JyB8ICdwZXRfb3duZXInO1xyXG59O1xyXG5cclxudHlwZSBBdXRoQ29udGV4dFZhbHVlID0ge1xyXG4gIHVzZXI6IFVzZXIgfCBudWxsO1xyXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcclxuICBsb2dpbjogKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIHJvbGU6ICd2ZXQnIHwgJ3BldF9vd25lcicpID0+IFByb21pc2U8dm9pZD47XHJcbiAgcmVnaXN0ZXI6IChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIHJvbGU6ICd2ZXQnIHwgJ3BldF9vd25lcicpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9naW5XaXRoR29vZ2xlOiAocm9sZTogJ3ZldCcgfCAncGV0X293bmVyJykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2dvdXQ6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRWYWx1ZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xyXG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbaW5pdGlhbGlzZWQsIHNldEluaXRpYWxpc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaW5pdEVycm9yLCBzZXRJbml0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIERlYnVnOiBMb2cgaW5pdGlhbGl6YXRpb24gc3RhdGVcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ0F1dGhQcm92aWRlcjogaW5pdGlhbGlzZWQgPScsIGluaXRpYWxpc2VkLCAndXNlciA9JywgdXNlcik7XHJcbiAgfSwgW2luaXRpYWxpc2VkLCB1c2VyXSk7XHJcblxyXG4gIGNvbnN0IGZldGNoVXNlclByb2ZpbGUgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIG1ldGFkYXRhTmFtZT86IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVHJ5IHRvIGdldCBwcm9maWxlIGZyb20gcHJvZmlsZXMgdGFibGUgZmlyc3QgLSB1c2UgbWF5YmVTaW5nbGUgdG8gaGFuZGxlIG1pc3NpbmcgcHJvZmlsZXNcclxuICAgICAgY29uc3QgeyBkYXRhOiBwcm9maWxlLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS5zZWxlY3QoJyonKS5lcSgnaWQnLCB1c2VySWQpLm1heWJlU2luZ2xlKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocHJvZmlsZSAmJiAhZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6IHByb2ZpbGUuaWQsXHJcbiAgICAgICAgICBuYW1lOiBwcm9maWxlLm5hbWUgfHwgbWV0YWRhdGFOYW1lIHx8IGVtYWlsLnNwbGl0KCdAJylbMF0gfHwgJ0FuaXdvbyB1c2VyJyxcclxuICAgICAgICAgIGVtYWlsOiBwcm9maWxlLmVtYWlsIHx8IGVtYWlsLFxyXG4gICAgICAgICAgcm9sZTogcHJvZmlsZS5yb2xlIGFzICd2ZXQnIHwgJ3BldF9vd25lcicgfCB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBwcm9maWxlIGRvZXNuJ3QgZXhpc3QsIHRyeSB0byBjcmVhdGUgaXRcclxuICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUHJvZmlsZSBub3QgZm91bmQsIGNyZWF0aW5nIGl0Li4uJyk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG1ldGFkYXRhTmFtZSB8fCBlbWFpbC5zcGxpdCgnQCcpWzBdIHx8ICdBbml3b28gdXNlcic7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhOiBuZXdQcm9maWxlLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuaW5zZXJ0KHtcclxuICAgICAgICAgIGlkOiB1c2VySWQsXHJcbiAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgZW1haWw6IGVtYWlsLFxyXG4gICAgICAgICAgcm9sZTogbnVsbFxyXG4gICAgICAgIH0pLnNlbGVjdCgpLnNpbmdsZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChuZXdQcm9maWxlICYmICFjcmVhdGVFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG5ld1Byb2ZpbGUuaWQsXHJcbiAgICAgICAgICAgIG5hbWU6IG5ld1Byb2ZpbGUubmFtZSB8fCBuYW1lLFxyXG4gICAgICAgICAgICBlbWFpbDogbmV3UHJvZmlsZS5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgICAgICAgcm9sZTogbmV3UHJvZmlsZS5yb2xlIGFzICd2ZXQnIHwgJ3BldF9vd25lcicgfCB1bmRlZmluZWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9maWxlOicsIGVycm9yKTtcclxuICAgICAgLy8gQ29udGludWUgdG8gZmFsbGJhY2tcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmFsbGJhY2sgdG8gYXV0aCBtZXRhZGF0YSBpZiBwcm9maWxlIGRvZXNuJ3QgZXhpc3Qgb3IgcXVlcnkgZmFpbHNcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiB1c2VySWQsXHJcbiAgICAgIG5hbWU6IG1ldGFkYXRhTmFtZSB8fCBlbWFpbC5zcGxpdCgnQCcpWzBdIHx8ICdBbml3b28gdXNlcicsXHJcbiAgICAgIGVtYWlsOiBlbWFpbCxcclxuICAgICAgcm9sZTogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBsZXQgbW91bnRlZCA9IHRydWU7XHJcblxyXG4gICAgLy8gV3JhcCBpbiB0cnktY2F0Y2ggdG8gcHJldmVudCBlcnJvcnMgZnJvbSBibG9ja2luZyByZW5kZXJcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNldCB1cCBhdXRoIHN0YXRlIGNoYW5nZSBsaXN0ZW5lciBGSVJTVCAtIHRoaXMgaGFuZGxlcyBzZXNzaW9uIHJlc3RvcmF0aW9uXHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBkYXRhOiB7IHN1YnNjcmlwdGlvbiB9XHJcbiAgICAgIH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKGFzeW5jIChldmVudCwgc2Vzc2lvbikgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgYXV0aCBldmVudHNcclxuICAgICAgICBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJyB8fCAhc2Vzc2lvbikge1xyXG4gICAgICAgICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB1ID0gc2Vzc2lvbj8udXNlcjtcclxuICAgICAgICBpZiAoIXUpIHtcclxuICAgICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9yIFRPS0VOX1JFRlJFU0hFRCBldmVudHMsIGRvbid0IHJlZmV0Y2ggZXZlcnl0aGluZyAtIGp1c3Qga2VlcCBjdXJyZW50IHVzZXJcclxuICAgICAgICBpZiAoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnKSB7XHJcbiAgICAgICAgICAvLyBTZXNzaW9uIHJlZnJlc2hlZCwgYnV0IHVzZXIgaXMgc3RpbGwgdGhlIHNhbWUgLSBkb24ndCByZWZldGNoXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgSU5JVElBTF9TRVNTSU9OIGFuZCBTSUdORURfSU4gLSByZXN0b3JlIHVzZXIgb24gcGFnZSBsb2FkL3JlZnJlc2hcclxuICAgICAgICBpZiAoZXZlbnQgPT09ICdJTklUSUFMX1NFU1NJT04nIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCBmZXRjaFVzZXJQcm9maWxlKFxyXG4gICAgICAgICAgICAgIHUuaWQsXHJcbiAgICAgICAgICAgICAgdS5lbWFpbCB8fCAnJyxcclxuICAgICAgICAgICAgICAodS51c2VyX21ldGFkYXRhIGFzIHsgbmFtZT86IHN0cmluZzsgZnVsbF9uYW1lPzogc3RyaW5nIH0gfCBudWxsKT8ubmFtZSB8fCBcclxuICAgICAgICAgICAgICAodS51c2VyX21ldGFkYXRhIGFzIHsgbmFtZT86IHN0cmluZzsgZnVsbF9uYW1lPzogc3RyaW5nIH0gfCBudWxsKT8uZnVsbF9uYW1lXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgc2V0VXNlcih1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXIgcHJvZmlsZSBvbiBpbml0aWFsIHNlc3Npb246JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAvLyBTZXQgdXNlciB3aXRoIGJhc2ljIGluZm8gZXZlbiBpZiBwcm9maWxlIGZldGNoIGZhaWxzXHJcbiAgICAgICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgICAgICAgICBpZDogdS5pZCxcclxuICAgICAgICAgICAgICAgIG5hbWU6ICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nIH0gfCBudWxsKT8ubmFtZSB8fCB1LmVtYWlsPy5zcGxpdCgnQCcpWzBdIHx8ICdVc2VyJyxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB1LmVtYWlsIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9sZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9uIHNpZ24gdXAgb3Igc2lnbiBpbiwgZW5zdXJlIHByb2ZpbGUgZXhpc3RzXHJcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnU0lHTkVEX0lOJyB8fCBldmVudCA9PT0gJ1NJR05FRF9VUCcpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhTmFtZSA9ICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nOyBmdWxsX25hbWU/OiBzdHJpbmcgfSB8IG51bGwpPy5uYW1lIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nOyBmdWxsX25hbWU/OiBzdHJpbmcgfSB8IG51bGwpPy5mdWxsX25hbWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBtZXRhZGF0YU5hbWUgfHwgdS5lbWFpbD8uc3BsaXQoJ0AnKVswXSB8fCAnQW5pd29vIHVzZXInO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHBlbmRpbmcgT0F1dGggcm9sZSBmcm9tIEdvb2dsZSBzaWduLWluXHJcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdSb2xlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVuZGluZ19vYXV0aF9yb2xlJykgYXMgJ3ZldCcgfCAncGV0X293bmVyJyB8IG51bGwgOiBudWxsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVXBzZXJ0IHByb2ZpbGUgdG8gZW5zdXJlIGl0IGV4aXN0cyAocHJlc2VydmUgZXhpc3Rpbmcgcm9sZSBpZiBzZXQsIHVzZSBwZW5kaW5nIHJvbGUgZm9yIG5ldyBPQXV0aCB1c2VycylcclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ1Byb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCdyb2xlJykuZXEoJ2lkJywgdS5pZCkubWF5YmVTaW5nbGUoKTtcclxuICAgICAgICAgICAgY29uc3Qgcm9sZVRvVXNlID0gZXhpc3RpbmdQcm9maWxlPy5yb2xlIHx8IHBlbmRpbmdSb2xlIHx8IG51bGw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLnVwc2VydCh7XHJcbiAgICAgICAgICAgICAgaWQ6IHUuaWQsXHJcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICBlbWFpbDogdS5lbWFpbCB8fCAnJyxcclxuICAgICAgICAgICAgICByb2xlOiByb2xlVG9Vc2UsXHJcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICBvbkNvbmZsaWN0OiAnaWQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2xlYXIgcGVuZGluZyByb2xlIGFmdGVyIHVzaW5nIGl0XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nUm9sZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwZW5kaW5nX29hdXRoX3JvbGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBzZXJ0aW5nIHByb2ZpbGU6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIHByb2ZpbGUgdXBzZXJ0IGZhaWxzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgU0lHTkVEX1VQIGV2ZW50c1xyXG4gICAgICAgIGlmIChldmVudCA9PT0gJ1NJR05FRF9VUCcpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgZmV0Y2hVc2VyUHJvZmlsZShcclxuICAgICAgICAgICAgICB1LmlkLFxyXG4gICAgICAgICAgICAgIHUuZW1haWwgfHwgJycsXHJcbiAgICAgICAgICAgICAgKHUudXNlcl9tZXRhZGF0YSBhcyB7IG5hbWU/OiBzdHJpbmc7IGZ1bGxfbmFtZT86IHN0cmluZyB9IHwgbnVsbCk/Lm5hbWUgfHwgXHJcbiAgICAgICAgICAgICAgKHUudXNlcl9tZXRhZGF0YSBhcyB7IG5hbWU/OiBzdHJpbmc7IGZ1bGxfbmFtZT86IHN0cmluZyB9IHwgbnVsbCk/LmZ1bGxfbmFtZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgICAgICAgIHNldFVzZXIodXNlckRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyIHByb2ZpbGUgaW4gYXV0aCBzdGF0ZSBjaGFuZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAvLyBTZXQgdXNlciB3aXRoIGJhc2ljIGluZm8gZXZlbiBpZiBwcm9maWxlIGZldGNoIGZhaWxzXHJcbiAgICAgICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgICAgICAgICBpZDogdS5pZCxcclxuICAgICAgICAgICAgICAgIG5hbWU6ICh1LnVzZXJfbWV0YWRhdGEgYXMgeyBuYW1lPzogc3RyaW5nIH0gfCBudWxsKT8ubmFtZSB8fCB1LmVtYWlsPy5zcGxpdCgnQCcpWzBdIHx8ICdVc2VyJyxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB1LmVtYWlsIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9sZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYXV0aCBzdGF0ZSBjaGFuZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IGNsZWFyIHVzZXIgb24gZXJyb3IgLSBrZWVwIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIC0gY2hlY2sgY3VycmVudCBzZXNzaW9uIGFmdGVyIGxpc3RlbmVyIGlzIHNldCB1cFxyXG4gICAgY29uc3QgaW5pdCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBHZXQgY3VycmVudCBzZXNzaW9uIC0gdGhpcyB3aWxsIHRyaWdnZXIgSU5JVElBTF9TRVNTSU9OIGV2ZW50XHJcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgbm8gc2Vzc2lvbiwgbWFyayBhcyBpbml0aWFsaXplZCAodXNlciBpcyBsb2dnZWQgb3V0KVxyXG4gICAgICAgIGlmICghc2Vzc2lvbiAmJiBtb3VudGVkKSB7XHJcbiAgICAgICAgICBzZXRJbml0aWFsaXNlZCh0cnVlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgc2Vzc2lvbiBleGlzdHMsIElOSVRJQUxfU0VTU0lPTiBldmVudCBzaG91bGQgaGFuZGxlIHVzZXIgcmVzdG9yYXRpb25cclxuICAgICAgICAvLyBCdXQgc2V0IGEgc2hvcnRlciB0aW1lb3V0IGFzIGJhY2t1cCAoc2FmZXR5IHRpbWVvdXQgd2lsbCBhbHNvIGNhdGNoIHRoaXMpXHJcbiAgICAgICAgaWYgKHNlc3Npb24gJiYgbW91bnRlZCkge1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtb3VudGVkICYmICFpbml0aWFsaXNlZCkge1xyXG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBpZiBJTklUSUFMX1NFU1NJT04gZGlkbid0IGZpcmUsIGluaXRpYWxpemUgYW55d2F5XHJcbiAgICAgICAgICAgICAgY29uc3QgdSA9IHNlc3Npb24udXNlcjtcclxuICAgICAgICAgICAgICBzZXRVc2VyKHtcclxuICAgICAgICAgICAgICAgIGlkOiB1LmlkLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogKHUudXNlcl9tZXRhZGF0YSBhcyB7IG5hbWU/OiBzdHJpbmcgfSB8IG51bGwpPy5uYW1lIHx8IHUuZW1haWw/LnNwbGl0KCdAJylbMF0gfHwgJ1VzZXInLFxyXG4gICAgICAgICAgICAgICAgZW1haWw6IHUuZW1haWwgfHwgJycsXHJcbiAgICAgICAgICAgICAgICByb2xlOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBzZXRJbml0aWFsaXNlZCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgNTAwKTsgLy8gU2hvcnRlciB0aW1lb3V0IC0gc2FmZXR5IHRpbWVvdXQgd2lsbCBjYXRjaCBpZiB0aGlzIGRvZXNuJ3RcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gaW5pdDonLCBlcnJvcik7XHJcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICAgIHNldEluaXRpYWxpc2VkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgbGlzdGVuZXIgaXMgc2V0IHVwIGZpcnN0XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdm9pZCBpbml0KCk7XHJcbiAgICB9LCA1MCk7XHJcbiAgICBcclxuICAgIC8vIFNhZmV0eSB0aW1lb3V0IC0gYWx3YXlzIGluaXRpYWxpemUgYWZ0ZXIgMTAwMG1zIG1heCBmb3IgZmFzdGVyIGxvYWRpbmdcclxuICAgIC8vIEluY3JlYXNlZCB0aW1lb3V0IHRvIGdpdmUgU3VwYWJhc2UgbW9yZSB0aW1lIHRvIHJlc3BvbmRcclxuICAgIGNvbnN0IHNhZmV0eVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKG1vdW50ZWQgJiYgIWluaXRpYWxpc2VkKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdBdXRoIGluaXRpYWxpemF0aW9uIHRpbWVvdXQgLSBmb3JjaW5nIGluaXRpYWxpemF0aW9uJyk7XHJcbiAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBtb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNhZmV0eVRpbWVvdXQpO1xyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyB1cCBhdXRoIGxpc3RlbmVyOicsIGVycm9yKTtcclxuICAgICAgLy8gRXZlbiBpZiBhdXRoIHNldHVwIGZhaWxzLCBtYXJrIGFzIGluaXRpYWxpemVkIHNvIGFwcCBjYW4gcmVuZGVyXHJcbiAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgc2V0SW5pdGlhbGlzZWQodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBtb3VudGVkID0gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBsb2dpbiA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCByb2xlOiAndmV0JyB8ICdwZXRfb3duZXInKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7IGVtYWlsLCBwYXNzd29yZCB9KTtcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gbG9nIGluLiBQbGVhc2UgY2hlY2sgeW91ciBjcmVkZW50aWFscy4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkYXRhLnVzZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVzZXIgZGF0YSByZXR1cm5lZCBmcm9tIGxvZ2luJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHUgPSBkYXRhLnVzZXI7XHJcblxyXG4gICAgICAvLyBXYWl0IGEgbW9tZW50IGZvciB0aGUgc2Vzc2lvbiB0byBiZSBmdWxseSBlc3RhYmxpc2hlZFxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XHJcblxyXG4gICAgICAvLyBWZXJpZnkgc2Vzc2lvbiBleGlzdHNcclxuICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XHJcbiAgICAgIGlmIChzZXNzaW9uRXJyb3IgfHwgIXNlc3Npb24pIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGVycm9yIGFmdGVyIGxvZ2luOicsIHNlc3Npb25FcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXN0YWJsaXNoIHNlc3Npb24uIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBwcm9maWxlIHdpdGggcm9sZSBpZiBub3QgYWxyZWFkeSBzZXRcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGRhdGE6IHByb2ZpbGUsIGVycm9yOiBwcm9maWxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxyXG4gICAgICAgICAgLnNlbGVjdCgncm9sZScpXHJcbiAgICAgICAgICAuZXEoJ2lkJywgdS5pZClcclxuICAgICAgICAgIC5tYXliZVNpbmdsZSgpO1xyXG5cclxuICAgICAgICBpZiAocHJvZmlsZUVycm9yICYmIHByb2ZpbGVFcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9maWxlOicsIHByb2ZpbGVFcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXByb2ZpbGU/LnJvbGUpIHtcclxuICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLnVwc2VydCh7XHJcbiAgICAgICAgICAgIGlkOiB1LmlkLFxyXG4gICAgICAgICAgICByb2xlOiByb2xlLFxyXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgb25Db25mbGljdDogJ2lkJ1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKHVwc2VydEVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHByb2ZpbGUgcm9sZTonLCB1cHNlcnRFcnJvcik7XHJcbiAgICAgICAgICAgIC8vIERvbid0IHRocm93IC0gcm9sZSB1cGRhdGUgaXMgb3B0aW9uYWxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKHByb2ZpbGVFcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBwcm9maWxlOicsIHByb2ZpbGVFcnIpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgcHJvZmlsZSB1cGRhdGUgZmFpbHNcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRmV0Y2ggcHJvZmlsZSBmcm9tIGRhdGFiYXNlXHJcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgZmV0Y2hVc2VyUHJvZmlsZShcclxuICAgICAgICB1LmlkLFxyXG4gICAgICAgIHUuZW1haWwgfHwgJycsXHJcbiAgICAgICAgKHUudXNlcl9tZXRhZGF0YSBhcyB7IG5hbWU/OiBzdHJpbmcgfSB8IG51bGwpPy5uYW1lXHJcbiAgICAgICk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVc2Ugcm9sZSBmcm9tIHByb2ZpbGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdXNlIHRoZSByb2xlIHBhc3NlZCBpblxyXG4gICAgICBjb25zdCBmaW5hbFJvbGUgPSB1c2VyRGF0YS5yb2xlIHx8IHJvbGU7XHJcbiAgICAgIHNldFVzZXIoeyAuLi51c2VyRGF0YSwgcm9sZTogZmluYWxSb2xlIH0pO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IHVzZXIgd2FzIHNldFxyXG4gICAgICBpZiAoIXVzZXJEYXRhLmlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCB1c2VyIHByb2ZpbGUnKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBmdW5jdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIC8vIFJlLXRocm93IHdpdGggYmV0dGVyIGVycm9yIG1lc3NhZ2VcclxuICAgICAgdGhyb3cgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKCdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIGR1cmluZyBsb2dpbicpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlZ2lzdGVyID0gYXN5bmMgKG5hbWU6IHN0cmluZywgZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgcm9sZTogJ3ZldCcgfCAncGV0X293bmVyJykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduVXAoe1xyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIHBhc3N3b3JkLFxyXG4gICAgICAgIG9wdGlvbnM6IHsgXHJcbiAgICAgICAgICBkYXRhOiB7IFxyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICBmdWxsX25hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIHJvbGU6IHJvbGVcclxuICAgICAgICAgIH0gXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIHNpZ251cCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgYWNjb3VudCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWRhdGEudXNlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBjcmVhdGlvbiBmYWlsZWQgLSBubyB1c2VyIGRhdGEgcmV0dXJuZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdSA9IGRhdGEudXNlcjtcclxuXHJcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBkYXRhYmFzZSB0cmlnZ2VyIHRvIGNyZWF0ZSB0aGUgcHJvZmlsZSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgIC8vIFRoZSB0cmlnZ2VyIHJ1bnMgd2l0aCBTRUNVUklUWSBERUZJTkVSLCBzbyBpdCBieXBhc3NlcyBSTFNcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MDApKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHByb2ZpbGUgd2FzIGNyZWF0ZWQgYnkgdHJpZ2dlclxyXG4gICAgICBsZXQgeyBkYXRhOiBleGlzdGluZ1Byb2ZpbGUsIGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGVtYWlsLCByb2xlLCBjcmVhdGVkX2F0JylcclxuICAgICAgICAuZXEoJ2lkJywgdS5pZClcclxuICAgICAgICAubWF5YmVTaW5nbGUoKTtcclxuXHJcbiAgICAgIGlmIChjaGVja0Vycm9yICYmIGNoZWNrRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2Jykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHByb2ZpbGU6JywgY2hlY2tFcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuXHJcbiAgICAgIGlmICghZXhpc3RpbmdQcm9maWxlKSB7XHJcbiAgICAgICAgLy8gUHJvZmlsZSB3YXNuJ3QgY3JlYXRlZCBieSB0cmlnZ2VyIC0gdHJ5IHRvIGNyZWF0ZSBpdCBtYW51YWxseVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdQcm9maWxlIG5vdCBmb3VuZCwgYXR0ZW1wdGluZyB0byBjcmVhdGUgbWFudWFsbHkuLi4nKTtcclxuICAgICAgICBjb25zdCB7IGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS5pbnNlcnQoe1xyXG4gICAgICAgICAgaWQ6IHUuaWQsXHJcbiAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgZW1haWw6IHUuZW1haWwgfHwgZW1haWwsXHJcbiAgICAgICAgICByb2xlOiByb2xlLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdDogbm93LFxyXG4gICAgICAgICAgdXBkYXRlZF9hdDogbm93XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChpbnNlcnRFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zZXJ0aW5nIHByb2ZpbGU6JywgaW5zZXJ0RXJyb3IpO1xyXG4gICAgICAgICAgLy8gV2FpdCBhIGJpdCBtb3JlIGFuZCBjaGVjayBhZ2FpbiAodHJpZ2dlciBtaWdodCBiZSBkZWxheWVkKVxyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcclxuICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmV0cnlDaGVjayB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcclxuICAgICAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCB1LmlkKVxyXG4gICAgICAgICAgICAubWF5YmVTaW5nbGUoKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKCFyZXRyeUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBwcm9maWxlOiAke2luc2VydEVycm9yLm1lc3NhZ2V9LiBQbGVhc2UgY2hlY2sgZGF0YWJhc2UgdHJpZ2dlciBzZXR1cC5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGV4aXN0aW5nUHJvZmlsZSA9IHJldHJ5Q2hlY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFByb2ZpbGUgZXhpc3RzIC0gdXBkYXRlIGl0IHdpdGggcm9sZSBhbmQgbmFtZVxyXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcclxuICAgICAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICBlbWFpbDogdS5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgICAgICAgcm9sZTogcm9sZSxcclxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbm93XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmVxKCdpZCcsIHUuaWQpO1xyXG5cclxuICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHByb2ZpbGU6JywgdXBkYXRlRXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGU6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZlcmlmeSBwcm9maWxlIHdhcyBjcmVhdGVkL3VwZGF0ZWRcclxuICAgICAgY29uc3QgeyBkYXRhOiB2ZXJpZnlQcm9maWxlLCBlcnJvcjogdmVyaWZ5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAuZXEoJ2lkJywgdS5pZClcclxuICAgICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgICBpZiAodmVyaWZ5RXJyb3IgfHwgIXZlcmlmeVByb2ZpbGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgcHJvZmlsZTonLCB2ZXJpZnlFcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9maWxlIHZlcmlmaWNhdGlvbiBmYWlsZWQuIFBsZWFzZSB0cnkgbG9nZ2luZyBpbi4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmV0Y2ggdGhlIGNvbXBsZXRlIHByb2ZpbGVcclxuICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCBmZXRjaFVzZXJQcm9maWxlKHUuaWQsIHUuZW1haWwgfHwgZW1haWwsIG5hbWUpO1xyXG4gICAgICBcclxuICAgICAgc2V0VXNlcih7XHJcbiAgICAgICAgLi4udXNlckRhdGEsXHJcbiAgICAgICAgcm9sZTogdmVyaWZ5UHJvZmlsZS5yb2xlIHx8IHJvbGVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnUmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwsIHByb2ZpbGUgY3JlYXRlZDonLCB2ZXJpZnlQcm9maWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKCdSZWdpc3RyYXRpb24gZmFpbGVkJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9naW5XaXRoR29vZ2xlID0gYXN5bmMgKHJvbGU6ICd2ZXQnIHwgJ3BldF9vd25lcicpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFN0b3JlIHRoZSByb2xlIGluIGxvY2FsU3RvcmFnZSBzbyB3ZSBjYW4gdXNlIGl0IGFmdGVyIE9BdXRoIGNhbGxiYWNrXHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZW5kaW5nX29hdXRoX3JvbGUnLCByb2xlKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVXNlIFN1cGFiYXNlJ3MgYnVpbHQtaW4gT0F1dGhcclxuICAgICAgLy8gVGhpcyB3aWxsIHJlZGlyZWN0IHRvIEdvb2dsZSwgdGhlbiBiYWNrIHRvIFN1cGFiYXNlJ3MgY2FsbGJhY2ssIHRoZW4gdG8gb3VyIHJlZGlyZWN0VG8gVVJMXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aE9BdXRoKHtcclxuICAgICAgICBwcm92aWRlcjogJ2dvb2dsZScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgcmVkaXJlY3RUbzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hdXRoL2NhbGxiYWNrYCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB7XHJcbiAgICAgICAgICAgIGFjY2Vzc190eXBlOiAnb2ZmbGluZScsXHJcbiAgICAgICAgICAgIHByb21wdDogJ2NvbnNlbnQnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BlbmRpbmdfb2F1dGhfcm9sZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIE9BdXRoIGZsb3cgd2lsbCByZWRpcmVjdCB0byBHb29nbGUsIHRoZW4gYmFjayB0byBvdXIgY2FsbGJhY2tcclxuICAgICAgLy8gVGhlIHNlc3Npb24gd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBhdXRoIHN0YXRlIGNoYW5nZSBsaXN0ZW5lclxyXG4gICAgICAvLyBObyBuZWVkIHRvIGRvIGFueXRoaW5nIGVsc2UgaGVyZSAtIHRoZSByZWRpcmVjdCBoYXBwZW5zIGF1dG9tYXRpY2FsbHlcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhdGluZyBHb29nbGUgT0F1dGg6JywgZXJyb3IpO1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncGVuZGluZ19vYXV0aF9yb2xlJyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0xvZ2dpbmcgb3V0Li4uJyk7XHJcbiAgICAgIC8vIFNpZ24gb3V0IGZyb20gU3VwYWJhc2VcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KCk7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIHNpZ25PdXQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhciBsb2NhbCBzdG9yYWdlXHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzdXBhYmFzZS5hdXRoLnRva2VuJyk7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BlbmRpbmdfb2F1dGhfcm9sZScpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhciB1c2VyIHN0YXRlXHJcbiAgICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdMb2dvdXQgY29tcGxldGUnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBsb2dvdXQ6JywgZXJyb3IpO1xyXG4gICAgICAvLyBTdGlsbCBjbGVhciB1c2VyIHN0YXRlIGV2ZW4gaWYgc2lnbk91dCBmYWlsc1xyXG4gICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIEFsd2F5cyByZW5kZXIgY2hpbGRyZW4gaW1tZWRpYXRlbHkgLSBkb24ndCBibG9jayBvbiBhdXRoIGluaXRpYWxpemF0aW9uXHJcbiAgLy8gQXV0aCB3aWxsIHVwZGF0ZSBpbiB0aGUgYmFja2dyb3VuZFxyXG4gIHJldHVybiAoXHJcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXJcclxuICAgICAgdmFsdWU9e3tcclxuICAgICAgICB1c2VyLFxyXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxyXG4gICAgICAgIGxvZ2luLFxyXG4gICAgICAgIHJlZ2lzdGVyLFxyXG4gICAgICAgIGxvZ2luV2l0aEdvb2dsZSxcclxuICAgICAgICBsb2dvdXRcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2luaXRFcnJvciA/IChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1saWdodCBwLTRcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctbWQgdy1mdWxsIHJvdW5kZWQtMnhsIGJnLXdoaXRlIHAtOCBzaGFkb3ctbGcgdGV4dC1jZW50ZXJcIj5cclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbGF0ZS02MDAgbWItNFwiPntpbml0RXJyb3J9PC9wPlxyXG4gICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpfVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtZnVsbCBiZy1wcmltYXJ5IHB4LTYgcHktMiB0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSB0cmFuc2l0aW9uIGhvdmVyOmJnLXByaW1hcnkvOTBcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgUmVsb2FkIFBhZ2VcclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKSA6IChcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgICApfVxyXG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXV0aCgpIHtcclxuICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcclxuICBpZiAoIWN0eCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjdHg7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJzdXBhYmFzZSIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwic2V0VXNlciIsImluaXRpYWxpc2VkIiwic2V0SW5pdGlhbGlzZWQiLCJpbml0RXJyb3IiLCJzZXRJbml0RXJyb3IiLCJjb25zb2xlIiwibG9nIiwiZmV0Y2hVc2VyUHJvZmlsZSIsInVzZXJJZCIsImVtYWlsIiwibWV0YWRhdGFOYW1lIiwiZGF0YSIsInByb2ZpbGUiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm1heWJlU2luZ2xlIiwiaWQiLCJuYW1lIiwic3BsaXQiLCJyb2xlIiwiY29kZSIsIm5ld1Byb2ZpbGUiLCJjcmVhdGVFcnJvciIsImluc2VydCIsInNpbmdsZSIsIm1vdW50ZWQiLCJzdWJzY3JpcHRpb24iLCJhdXRoIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJldmVudCIsInNlc3Npb24iLCJ1IiwidXNlckRhdGEiLCJ1c2VyX21ldGFkYXRhIiwiZnVsbF9uYW1lIiwicGVuZGluZ1JvbGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZXhpc3RpbmdQcm9maWxlIiwicm9sZVRvVXNlIiwidXBzZXJ0IiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm9uQ29uZmxpY3QiLCJyZW1vdmVJdGVtIiwiaW5pdCIsImdldFNlc3Npb24iLCJzZXRUaW1lb3V0Iiwic2FmZXR5VGltZW91dCIsIndhcm4iLCJ1bnN1YnNjcmliZSIsImNsZWFyVGltZW91dCIsImxvZ2luIiwicGFzc3dvcmQiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJFcnJvciIsIm1lc3NhZ2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNlc3Npb25FcnJvciIsInByb2ZpbGVFcnJvciIsInVwc2VydEVycm9yIiwicHJvZmlsZUVyciIsImZpbmFsUm9sZSIsInJlZ2lzdGVyIiwic2lnblVwIiwib3B0aW9ucyIsImNoZWNrRXJyb3IiLCJub3ciLCJpbnNlcnRFcnJvciIsImNyZWF0ZWRfYXQiLCJyZXRyeUNoZWNrIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJ2ZXJpZnlQcm9maWxlIiwidmVyaWZ5RXJyb3IiLCJsb2dpbldpdGhHb29nbGUiLCJzZXRJdGVtIiwic2lnbkluV2l0aE9BdXRoIiwicHJvdmlkZXIiLCJyZWRpcmVjdFRvIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJxdWVyeVBhcmFtcyIsImFjY2Vzc190eXBlIiwicHJvbXB0IiwibG9nb3V0Iiwic2lnbk91dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJpc0F1dGhlbnRpY2F0ZWQiLCJkaXYiLCJjbGFzc05hbWUiLCJwIiwiYnV0dG9uIiwib25DbGljayIsInJlbG9hZCIsInVzZUF1dGgiLCJjdHgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/providers/AuthProvider.tsx\n"));

/***/ })

});